# 11장 원시 값과 객체의 비교

| 구분         | 원시 타입               | 객체 타입           |
| ------------ | ----------------------- | ------------------- |
| 값의 저장    | 실제 값 저장            | 참조 값 저장        |
| 변경 가능성  | 변경 불가능 (immutable) | 변경 가능 (mutable) |
| 변수 할당 시 | 값에 의한 전달          | 참조에 의한 전달    |

## 11.1 원시 값

### 11.1.1 변경 불가능한 값

- 원시 타입의 값은 **변경 불가능한 값 (immutable value)**
- "변경 불가능"은 **변수가 아니라 값**에 대한 진술

> **상수 vs 불변성**: 상수는 재할당이 금지된 변수, 불변성은 값 자체의 특성

```javascript
var score = 80;
score = 90; // 80을 변경한 게 아니라, 새로운 메모리에 90을 저장하고 참조 변경
```

**불변성 (Immutability)**

재할당 시 기존 메모리의 값을 변경하는 것이 아니라:

1. 새로운 메모리 공간 확보
2. 재할당한 원시 값 저장
3. 변수가 새로운 메모리 공간을 가리키도록 변경

> 불변성을 갖는 원시 값은 **재할당 이외에 값을 변경할 방법이 없다**

### 11.1.2 문자열과 불변성

- 문자열은 **1개 문자당 2바이트** 메모리 사용
- 문자 개수에 따라 필요한 메모리 공간 크기가 결정됨

```javascript
var str = "Hello";
str = "world"; // 'Hello'를 변경한 게 아니라, 'world'를 새로 생성하고 참조 변경
```

**유사 배열 객체 (Array-like Object)**

```javascript
var str = "string";

// 배열처럼 인덱스로 접근 가능
console.log(str[0]); // 's'
console.log(str.length); // 6

// 하지만 원시 값이므로 변경 불가
str[0] = "S";
console.log(str); // 'string' (변경 안 됨)
```

> 문자열은 **읽기 전용** → 데이터 신뢰성 보장

### 11.1.3 값에 의한 전달

```javascript
var score = 80;
var copy = score; // 값 80이 복사되어 전달

console.log(score); // 80
console.log(copy); // 80
console.log(score === copy); // true (값이 같음)

score = 100;

console.log(score); // 100
console.log(copy); // 80 (영향 없음!)
```

> 두 변수의 원시 값은 **다른 메모리 공간에 저장된 별개의 값**

**핵심**: 한쪽에서 재할당해도 다른 쪽에 **영향을 주지 않음**

```
[score: 80] ──복사──> [copy: 80]  (별개의 메모리)
     │
     ↓ 재할당
[score: 100]         [copy: 80]  (서로 독립적)
```

> 엄밀히 말하면 "값에 의한 전달"도 실제로는 **메모리 주소를 전달**하는 것

## 11.2 객체

- 객체는 원시 값과 달리 **메모리 공간의 크기를 사전에 정해둘 수 없음**
- 프로퍼티와 메서드를 동적으로 추가/삭제 가능

**JS 객체의 관리 방식**

- JS는 클래스 없이 객체 생성 가능 (프로토타입 기반)
- 클래스 기반 언어보다 객체 생성/프로퍼티 접근에 비용이 더 듦
- V8 엔진은 **히든 클래스(Hidden Class)** 방식으로 성능 최적화

### 11.2.1 변경 가능한 값

객체는 **변경 가능한 값 (mutable value)**

```javascript
var person = { name: "Lee" };
```

| 구분              | 표현 방식                         |
| ----------------- | --------------------------------- |
| 원시 값 할당 변수 | "변수는 ~값을 **갖는다**"         |
| 객체 할당 변수    | "변수는 객체를 **참조하고 있다**" |

```javascript
var person = { name: "Lee" };

// 재할당 없이 직접 변경 가능
person.name = "Kim"; // 프로퍼티 값 갱신
person.address = "Seoul"; // 프로퍼티 동적 추가
delete person.address; // 프로퍼티 삭제

console.log(person); // { name: 'Kim' }
```

> 객체를 변경해도 **참조 값(메모리 주소)은 변경되지 않음**

**객체의 구조적 단점**: 여러 식별자가 하나의 객체를 공유할 수 있음

### 얕은 복사 vs 깊은 복사

```javascript
const o = { x: { y: 1 } };

// 얕은 복사 (shallow copy) - 한 단계만 복사
const c1 = { ...o };
console.log(c1 === o); // false
console.log(c1.x === o.x); // true (중첩 객체는 같은 참조)

// 깊은 복사 (deep copy) - 중첩 객체까지 모두 복사
const c2 = JSON.parse(JSON.stringify(o));
console.log(c2 === o); // false
console.log(c2.x === o.x); // false (완전히 별개)
```

| 복사 방식 | 설명                    | 중첩 객체      |
| --------- | ----------------------- | -------------- |
| 얕은 복사 | 한 단계만 복사          | 같은 참조 공유 |
| 깊은 복사 | 중첩 객체까지 모두 복사 | 완전히 별개    |

### 11.2.2 참조에 의한 전달

객체를 가리키는 변수를 다른 변수에 할당하면 **참조 값이 복사**됨

```javascript
var person = { name: "Lee" };
var copy = person; // 참조 값 복사

console.log(person === copy); // true (같은 객체 참조)
```

```
person ──┐
         ├──> { name: 'Lee' }  (동일한 객체)
copy   ──┘
```

**두 식별자가 하나의 객체를 공유** → 한쪽 변경 시 서로 영향

```javascript
var person = { name: "Lee" };
var copy = person;

copy.name = "Kim";
person.address = "Seoul";

console.log(person); // { name: 'Kim', address: 'Seoul' }
console.log(copy); // { name: 'Kim', address: 'Seoul' }
```

> JS에는 엄밀히 "참조에 의한 전달"은 없고, **값에 의한 전달만 존재**한다고 볼 수 있음
> (전달되는 값이 원시 값이냐 참조 값이냐의 차이)

## Quiz

```javascript
var person1 = { name: "Lee" };
var person2 = { name: "Lee" };

console.log(person1 === person2); // ?
console.log(person1.name === person2.name); // ?
```

**정답**

| 비교                            | 결과    | 이유                                               |
| ------------------------------- | ------- | -------------------------------------------------- |
| `person1 === person2`           | `false` | 내용은 같지만 **다른 메모리에 저장된 별개의 객체** |
| `person1.name === person2.name` | `true`  | `'Lee'` === `'Lee'` (원시 값 비교, 값이 같음)      |
