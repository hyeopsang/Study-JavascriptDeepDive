# 11장. 원시 값과 객체의 비교

## 📁 원시값
### 🗒️ 변경 불가능한 값 (불변성)
- 한번 생성된 원시 값은 읽기 전용 값으로서 변경 불가.
- 이는 변수에 대한게 아니라 <u>값에 대한 진술</u>임.
- **불변성**을 갖는 원시 값을 할당한 변수는 **재할당** 이외에 변수 값을 변경할 방법이 없음.
### 🗒️ 문자열과 불변성
- 문자열은 유사 배열 객체이면서 이터러블이므로 배열과 유사하게 각 문자에 접근 가능.
  ```js
  const str = 'string';
  
  console.log(str[0]);  // s
  
  console.log(str.length);  // 6
  console.log(str.toUpperCase());  // STRING
  ```
- 원시 객체이므로 문자열은 불변성을 갖음.
  ```js
  let str = 'string';
  
  // 문자열은 원시 값이므로 변경 불가. 에러가 발생하진 않음.
  str[0] = 'S';
  
  console.log(str);  // string
  ```
- 예기치 못한 변경으로 부터 자유롭고, 이로 인해 신뢰성이 보장됨.
### 🗒️ 값에 의한 전달
- 변수에 원시 값을 갖는 변수를 할당하면 할당받는 변수에는 할당되는 변수의 메모리 주소가 전달 됨.
- 아래 코드를 보면 두 변수의 값은 서로 같은 메모리 주소를 참조 하지만, 값의 재할당을 통해 참조하는 메모리 주소가 변경되어 서로 다른 별개의 값을 참조하게 됨.
  ```js
  let score = 80;
  let copy = score;
  
  console.log(score);  // 80
  console.log(copy);  // 80
  
  score = 100;
  
  console.log(score);  // 100
  console.log(copy);  // 80
  ```

<br/>

## 📁 객체
### 🗒️ 변경 가능한 값
- 객체는 변경 가능한 값이므로 **재할당 없이** 객체를 직접 변경이 가능.
- 메모리에 저장된 객체를 직접 수정하고, 재할당 하지 않았으므로 할당한 변수의 참조 값은 변하지 않음.
- **단점**: 여러 개의 식별자가 <u>하나의 객체를 공유</u>할 수 있다는 점.
### 참조에 의한 전달
- 객체를 할당한 변수를 다른 변수에 할당하게 되면, 하나의 객체를 참조하게 됨.
  ```js
  const person = {
    name: 'Lee'
  }
  
  const copy = person;
  
  console.log(copy === person);  // true
  
  copy.name = 'Kim';
  person.address = 'Seoul';
  
  console.log(person);  // {name: "Kim", address: "Seoul"}
  console.log(copy);  // {name: "Kim", address: "Seoul"}
  ```
