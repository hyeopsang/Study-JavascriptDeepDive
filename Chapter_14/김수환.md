# 14장 전역 변수의 문제점

## 14.1 변수의 생명 주기

### 14.1.1 지역 변수의 생명 주기

지역 변수는 함수가 호출되면 생성되고 함수가 종료되면 소멸한다.

```javascript
function foo() {
  var x = "local";
  console.log(x); // local
  return x;
}
foo();
console.log(x); // ReferenceError
```

- `x`는 `foo` 함수가 호출되지 않으면 함수 내부의 변수 선언문이 실행되지 않아 생성되지 않는다.
- 호이스팅(런타임 이전에 변수가 선언되는 것)은 **스코프 단위**로 동작한다.
- 지역 변수는 함수가 호출되어 실행되는 동안에만 유효하다.
- **지역 변수의 생명주기 = 함수의 생명주기**

```javascript
function foo() {
  var x = "local"; // 변수 x 생성 ─┐
  console.log(x); // 변수 x 사용   │ 변수 x의 생명주기
  return x; // 변수 x 소멸 ─┘
}
```

#### 스코프와 생명주기

- 지역 변수는 스코프에 등록된다.
- 스코프는 **렉시컬 환경**이라 부르는 물리적인 실체가 있다.
- 변수는 자신이 등록된 스코프가 소멸될 때까지 유효하다.
- 변수가 더 이상 참조되지 않을 때 **가비지 컬렉터**에 의해 해제되어 가용 메모리 풀에 반환된다.
- 스코프도 일반적으로 함수가 종료하면 소멸하지만, 누군가 스코프를 참조하고 있다면 생존하게 된다. (→ 24장 '클로저')

#### 호이스팅과 스코프

```javascript
var x = "global";
function foo() {
  console.log(x); // undefined (global이 아님!)
  var x = "local";
}
foo();
console.log(x); // global
```

`foo` 내부에서 `console.log(x)`가 `undefined`인 이유:

- 지역 변수 `x`가 호이스팅되어 함수 스코프 최상단에서 선언됨
- 실행 순서: `var x` → `console.log(x)` → `x = 'local'`

| 변수 종류 | 호이스팅 위치           |
| --------- | ----------------------- |
| 전역 변수 | 전역 스코프 최상단      |
| 지역 변수 | 해당 함수 스코프 최상단 |

### 14.1.2 전역 변수의 생명 주기

- `var` 키워드로 선언한 전역 변수는 **전역 객체의 프로퍼티**가 된다.
- 전역 변수의 생명주기 = 전역 객체의 생명주기

**전역 객체란?**
| 환경 | 전역 객체 |
|------|-----------|
| 브라우저 (클라이언트) | `window` |
| Node.js (서버) | `global` |
| ES11 통일 | `globalThis` |

> 전역 객체를 "가장 바깥쪽 함수"처럼 생각하면 이해하기 편하다.

---

## 14.2 전역 변수의 문제점

### 1. 암묵적 결합

모든 코드가 전역 변수를 참조하고 변경할 수 있는 **암묵적 결합**을 허용한다.

```javascript
var global = "hello";

function a() {
  global = "changed by a"; // 변경 가능
}

function b() {
  console.log(global); // 참조 가능
}

function c() {
  global = "changed by c"; // 또 변경 가능
}
```

→ 값을 추적하기 어렵고 가독성이 나빠진다.

### 2. 긴 생명주기

- 전역 변수는 생명주기가 길어 메모리 리소스를 오랜 기간 소비한다.
- `var`는 변수의 중복 선언을 허용하므로 의도치 않은 재할당이 일어날 수 있다.

```javascript
var x = 1;
var x = 2;
console.log(x); // 2
```

### 3. 스코프 체인 상에서 종점에 존재

- 전역 변수는 스코프 체인 상에서 종점에 존재하기 때문에 검색 속도가 가장 느리다.

> **스코프 체인**: 상위 스코프로 연결된 검색 경로

### 4. 네임스페이스 오염

자바스크립트는 파일이 분리되어 있어도 하나의 전역 스코프를 공유한다.
→ 다른 파일에서 동일한 이름의 전역 변수/함수가 있으면 충돌 발생

| 방식                       | 스코프             | 충돌 여부    |
| -------------------------- | ------------------ | ------------ |
| `<script src>` (옛날 방식) | 전역 공유          | ⚠️ 충돌 발생 |
| ES6 모듈 `import/export`   | 파일별 모듈 스코프 | ✅ 충돌 없음 |

---

## 14.3 전역 변수의 사용을 억제하는 방법

> 변수의 스코프는 좁을수록 좋다. 지역 변수 사용 권장!

### 14.3.1 즉시 실행 함수 (IIFE)

모든 코드를 즉시 실행 함수로 감싸면 모든 변수는 지역 변수가 된다.

```javascript
(function () {
  var x = 10; // 지역 변수
  // ...
})();

console.log(x); // ReferenceError
```

### 14.3.2 네임스페이스 객체

전역에 네임스페이스 역할을 담당할 객체를 생성하고 변수를 프로퍼티로 추가하는 방법

```javascript
var MYAPP = {};
MYAPP.name = "lee";
MYAPP.person = { name: "lee" };
```

⚠️ 네임스페이스 객체 자체가 전역 변수에 할당되므로 권장하지 않음

### 14.3.3 모듈 패턴

**클로저**: 내부 함수에서 외부 함수의 변수에 접근할 수 있는 기능
**캡슐화**: 프로퍼티와 메서드를 하나로 묶는 것. 정보 은닉을 위해 사용

> 자바스크립트는 `public`, `private` 같은 접근 제한자를 제공하지 않는다.
> 모듈 패턴을 사용하면 클로저를 통해 private 변수를 구현할 수 있다.

```javascript
var Counter = (function () {
  var num = 0; // private 변수

  return {
    increase() {
      return ++num;
    },
    decrease() {
      return --num;
    },
  };
})();

console.log(Counter.num); // undefined (직접 접근 불가)
console.log(Counter.increase()); // 1
console.log(Counter.increase()); // 2
console.log(Counter.decrease()); // 1
```

#### 동작 과정

1. 익명 함수가 **정의되자마자 즉시 실행**됨 `()`
2. 실행 결과로 `{ increase, decrease }` 객체가 **반환**됨
3. 그 객체가 `Counter` 변수에 **할당**됨

#### Counter는 함수가 아니라 객체

| 코드                                  | 결과                        |
| ------------------------------------- | --------------------------- |
| `var Counter = function(){ ... }`     | Counter는 **함수**          |
| `var Counter = (function(){ ... })()` | Counter는 **반환값 (객체)** |

```javascript
console.log(typeof Counter); // "object"
```

#### 왜 private 변수가 되는가?

| 구분         | 설명                                                   |
| ------------ | ------------------------------------------------------ |
| `num`        | 즉시실행함수의 **지역 변수** (외부 접근 불가)          |
| `Counter`    | 반환된 **객체** (`increase`, `decrease` 메서드만 가짐) |
| private 이유 | **클로저**에 의해 `num`은 메서드를 통해서만 접근 가능  |

`num`은 객체의 프로퍼티가 아니라 **클로저에 의해 은닉된 자유 변수**이기 때문에 private처럼 동작한다.

### 14.3.4 ES6 모듈

- ES6 모듈은 파일 자체의 **독자적인 모듈 스코프**를 제공한다.
- 모듈 내에서 선언한 `var` 변수는 전역 변수가 아니고 `window` 객체의 프로퍼티도 아니다.

```html
<script type="module" src="app.js"></script>
```

> 실무에서는 ES6 모듈 기능보다 **Webpack** 등의 모듈 번들러를 사용하는 것이 일반적이다.
