# 15장 let, const 키워드와 블록 레벨 스코프

## 15.1 var 키워드로 선언한 변수의 문제점

### 15.1.1 변수 중복 선언 허용

`var` 키워드로 선언한 변수는 중복 선언이 가능하다.

```javascript
var x = 1;
var x = 100;  // 중복 선언 + 할당 → 값 덮어씀

var y = 1;    // 선언 + 할당
var y;        // 중복 선언만 (할당 없음) → 무시됨

console.log(x); // 100
console.log(y); // 1
```

→ 의도치 않게 먼저 선언된 변수 값이 변경될 수 있음

### 15.1.2 함수 레벨 스코프

`var`는 **함수 레벨 스코프**만 인정한다. `if`, `for` 등의 코드 블록은 스코프로 인정하지 않음.

```javascript
var x = 1;
if (true) {
    var x = 10;  // 전역 변수 x를 덮어씀
}
console.log(x); // 10
```

→ 의도치 않게 전역 변수가 중복 선언됨

### 15.1.3 변수 호이스팅

변수 호이스팅에 의해 선언이 먼저 되어서 참조가 가능하다. 할당문 이전에 변수를 참조하면 `undefined`가 반환된다.

```javascript
console.log(x); // undefined (에러 안 남)
var x = 10;
```

→ 가독성을 떨어트리고 오류를 발생시킬 여지가 남음

---

## 15.2 let 키워드

### 15.2.1 변수 중복 선언 금지

`let`으로 선언한 변수를 중복 선언하면 **문법 에러(SyntaxError)** 발생

```javascript
let x = 1;
let x = 2;  // SyntaxError: Identifier 'x' has already been declared
```

### 15.2.2 블록 레벨 스코프

`let`은 모든 코드 블록(`if`, `for`, `while`, `함수` 등)을 지역 스코프로 인정하는 **블록 레벨 스코프**를 따른다.

```javascript
let i = 10;            // 전역 스코프

function foo() {
    let i = 100;       // foo 함수 스코프

    for (let i = 1; i < 3; i++) {  // for 블록 스코프
        console.log(i);  // 1, 2
    }

    console.log(i);  // 100
}

foo();
console.log(i);  // 10
```

| 위치 | 스코프 | i 값 |
|------|--------|------|
| 전역 | 전역 스코프 | 10 |
| foo 내부 | 함수 스코프 | 100 |
| for 내부 | 블록 스코프 | 1, 2 |

### 15.2.3 변수 호이스팅

`let` 키워드는 변수 호이스팅이 발생하지 않는 것**처럼** 동작한다.

#### var vs let 호이스팅 차이

| 단계 | var | let |
|------|-----|-----|
| 1. 선언 | ✅ 호이스팅 | ✅ 호이스팅 |
| 2. 초기화 | ✅ `undefined`로 즉시 초기화 | ❌ 코드 도달 시까지 대기 |
| 3. 할당 | 코드 도달 시 | 코드 도달 시 |

#### TDZ (Temporal Dead Zone, 일시적 사각지대)

```
┌─────────────────────┐
│ 선언 단계 (호이스팅) │ ─┐
├─────────────────────┤  │ TDZ (참조 에러)
│ ...                 │  │
├─────────────────────┤ ─┘
│ 초기화 단계         │ ← let x = 1; (여기서 초기화)
├─────────────────────┤
│ 할당 단계           │
└─────────────────────┘
```

```javascript
let foo = 1;  // 전역 변수
{
    console.log(foo);  // ReferenceError (TDZ)
    let foo = 2;       // 지역 변수
}
```

**왜 에러가 나는가?**
- 호이스팅이 **없다면**: 전역 `foo`(1)를 참조했을 것
- 호이스팅이 **있기 때문에**: 블록 내부의 `foo`를 인식 → 하지만 아직 초기화 안 됨 → TDZ → ReferenceError

### 15.2.4 전역 객체와 let

- `var`로 선언한 전역 변수: `window` 객체의 프로퍼티가 됨
- `let`으로 선언한 전역 변수: `window` 객체의 프로퍼티가 **아님**

```javascript
var x = 1;
let y = 2;

console.log(window.x);  // 1
console.log(window.y);  // undefined
```

→ `let` 전역 변수는 보이지 않는 개념적인 블록 내에 존재한다 (23장 실행 컨텍스트)

---

## 15.3 const 키워드

`const`는 **상수**를 선언하기 위해 사용한다. 특징은 `let`과 비슷하지만 다른 점이 있다.

### 15.3.1 선언과 초기화

`const`로 선언한 변수는 **선언과 동시에 초기화**해야 한다.

```javascript
const foo;  // SyntaxError: Missing initializer in const declaration
```

### 15.3.2 재할당 금지

`let`은 재할당이 되지만, `const`는 **재할당이 금지**된다.

```javascript
const foo = 1;
foo = 2;  // TypeError: Assignment to constant variable
```

### 15.3.3 상수

**상수**: 재할당이 금지된 변수

상수는 상태 유지와 가독성, 유지보수의 편의를 위해 적극적으로 사용한다.

```javascript
// 나쁜 예 - 0.1이 무엇을 의미하는지 알 수 없음
let price = 100;
let taxPrice = price + (price * 0.1);

// 좋은 예 - 상수로 의미를 명확히 함
const TAX_RATE = 0.1;  // 세율
let price = 100;
let taxPrice = price + (price * TAX_RATE);
```

- 상수는 **대문자 + 스네이크 케이스**로 선언해 상수임을 명확히 나타낸다
- `const`로 선언된 변수에 원시 값을 할당한 경우, 할당된 값을 변경할 수 있는 방법은 없다

### 15.3.4 const 키워드와 객체

`const` 변수에 **원시 값**을 할당한 경우 바꿀 수 없지만, **객체**를 할당한 경우 값을 변경할 수 있다.

> **const의 의미**: 재할당 금지 O, 불변 X

```javascript
const person = { name: 'Lee' };

// 객체 내용 변경 (가능)
person.name = 'Kim';  // ✅ OK

// 참조값 변경 (불가능)
person = { name: 'Park' };  // ❌ TypeError
```

| 구분 | 설명 | const |
|------|------|-------|
| 참조값 (주소) | 변수가 가리키는 메모리 주소 | ❌ 변경 불가 |
| 객체 내용 | 실제 객체의 프로퍼티 | ✅ 변경 가능 |

객체가 변경되더라도 변수에 할당된 **참조값(주소)**은 변경되지 않기 때문에 `const`로 선언해도 객체 내용은 수정 가능하다.

---

## 15.4 var vs let vs const

| 구분 | var | let | const |
|------|-----|-----|-------|
| 중복 선언 | ✅ 가능 | ❌ 불가 | ❌ 불가 |
| 재할당 | ✅ 가능 | ✅ 가능 | ❌ 불가 |
| 스코프 | 함수 레벨 | 블록 레벨 | 블록 레벨 |
| 호이스팅 | 선언 + 초기화 | 선언만 (TDZ) | 선언만 (TDZ) |
| 전역 객체 프로퍼티 | ✅ 됨 | ❌ 안 됨 | ❌ 안 됨 |

### 사용 권장

1. ES6부터는 `var` 사용 ❌
2. 변수 선언에 기본적으로 `const` 사용
3. 재할당이 필요한 경우에만 `let` 사용
4. 변수를 선언하는 시점에서 재할당이 필요한지 모르는 경우가 많으니, 일단 `const`로 선언 후 재할당이 필요하면 `let`으로 변경
