# 16장 프로퍼티 어트리뷰트

## 16.1 내부 슬롯과 내부 메서드

내부 슬롯과 내부 메서드는 자바스크립트 엔진의 구현 알고리즘을 설명하기 위해 ECMAScript 사양에서 사용하는 의사 프로퍼티와 의사 메서드다. 이중 대괄호로 감싸서 표현한다. (`[[...]]`)

```javascript
const o = {};
// 내부 슬롯은 자바스크립트 엔진의 내부 로직이므로 직접 접근할 수 없다.
o.[[Prototype]] // Uncaught SyntaxError
// 일부만 간접적으로 접근할 수 있는 수단을 제공한다.
o.__proto__ // -> Object.prototype
```

## 16.2 프로퍼티 어트리뷰트와 프로퍼티 디스크립터 객체

자바스크립트 엔진은 프로퍼티를 생성할 때 프로퍼티의 상태를 나타내는 프로퍼티 어트리뷰트를 기본값으로 자동 정의한다.

프로퍼티 상태:
- 값 `[[Value]]`
- 값의 갱신 가능 여부 `[[Writable]]`
- 열거 가능 여부 `[[Enumerable]]`
- 재정의 가능 여부 `[[Configurable]]`

직접 접근할 수 없지만 `Object.getOwnPropertyDescriptor` 메서드를 사용해 간접적으로 확인할 수 있다.

```javascript
const person = {
    name: "Lee"
};
console.log(Object.getOwnPropertyDescriptor(person, 'name'));
// {value: "Lee", writable: true, enumerable: true, configurable: true}
```

- `Object.getOwnPropertyDescriptor` 메서드는 프로퍼티 어트리뷰트 정보를 제공하는 **프로퍼티 디스크립터 객체**를 반환한다. 존재하지 않는 프로퍼티를 지정하면 `undefined`를 반환한다.
- `Object.getOwnPropertyDescriptor` — 하나의 프로퍼티에 대한 디스크립터 반환
- `Object.getOwnPropertyDescriptors` — 모든 프로퍼티에 대한 프로퍼티 디스크립터 반환 (ES8)

## 16.3 데이터 프로퍼티와 접근자 프로퍼티

- **데이터 프로퍼티**: 키와 값으로 구성된 일반적인 프로퍼티
- **접근자 프로퍼티**: 자체적으로 값을 갖지 않고 다른 데이터 프로퍼티의 값을 읽거나 저장할 때 호출되는 접근자 함수로 구성된 프로퍼티

### 16.3.1 데이터 프로퍼티

| 프로퍼티 어트리뷰트 | 프로퍼티 디스크립터 객체의 프로퍼티 | 설명 |
|---|---|---|
| `[[Value]]` | `value` | 프로퍼티 키를 통해 프로퍼티 값에 접근하면 반환되는 값 |
| `[[Writable]]` | `writable` | 프로퍼티 값의 변경 가능 여부 (boolean) |
| `[[Enumerable]]` | `enumerable` | 프로퍼티의 열거 가능 여부 (boolean). `false`이면 `for...in`, `Object.keys` 등으로 열거 불가 |
| `[[Configurable]]` | `configurable` | 프로퍼티의 재정의 가능 여부 (boolean). `false`이면 해당 프로퍼티 삭제, 어트리뷰트 값 변경 금지 |

### 16.3.2 접근자 프로퍼티

| 프로퍼티 어트리뷰트 | 프로퍼티 디스크립터 객체의 프로퍼티 | 설명 |
|---|---|---|
| `[[Get]]` | `get` | 데이터 프로퍼티의 값을 읽을 때 호출되는 접근자 함수 (getter) |
| `[[Set]]` | `set` | 데이터 프로퍼티의 값을 저장할 때 호출되는 접근자 함수 (setter) |
| `[[Enumerable]]` | `enumerable` | 데이터 프로퍼티와 같다 |
| `[[Configurable]]` | `configurable` | 데이터 프로퍼티와 같다 |

```javascript
const person = {
    firstName: 'Ungmo',
    lastName: 'Lee',

    // getter 함수
    get fullName() {
        return `${this.firstName} ${this.lastName}`;
    },
    // setter 함수
    set fullName(name) {
        [this.firstName, this.lastName] = name.split(' ');
    }
};

// 접근자 프로퍼티를 통한 값의 저장 (setter 호출)
person.fullName = 'Heegun Lee';
console.log(person); // {firstName: "Heegun", lastName: "Lee"}

// 접근자 프로퍼티를 통한 값의 참조 (getter 호출)
console.log(person.fullName); // Heegun Lee

// 데이터 프로퍼티 → value, writable, enumerable, configurable
console.log(Object.getOwnPropertyDescriptor(person, 'firstName'));
// {value: "Heegun", writable: true, enumerable: true, configurable: true}

// 접근자 프로퍼티 → get, set, enumerable, configurable
console.log(Object.getOwnPropertyDescriptor(person, 'fullName'));
// {get: f, set: f, enumerable: true, configurable: true}
```

> **프로토타입**: 어떤 객체의 부모 역할을 하는 객체. 자식 객체에게 프로퍼티와 메서드를 상속한다. (19장에서 자세히 다룸)

데이터 프로퍼티와 접근자 프로퍼티의 구분: `Object.getOwnPropertyDescriptor`로 확인했을 때 디스크립터 객체에 `value`가 있으면 데이터 프로퍼티, `get`이 있으면 접근자 프로퍼티다.

## 16.4 프로퍼티 정의

프로퍼티 정의란 새로운 프로퍼티를 추가하면서 프로퍼티 어트리뷰트를 명시적으로 정의하거나, 기존 프로퍼티의 어트리뷰트를 재정의하는 것이다. `Object.defineProperty` 메서드를 사용한다.

```javascript
const person = {};

// 데이터 프로퍼티 정의
Object.defineProperty(person, 'firstName', {
    value: 'Ungmo',     // 누락하면 undefined
    writable: true,      // 누락하면 false
    enumerable: true,    // 누락하면 false
    configurable: true,  // 누락하면 false
});

Object.defineProperty(person, 'lastName', {
    value: 'Lee',
    // 나머지 누락 시 전부 false
});

// 접근자 프로퍼티 정의
Object.defineProperty(person, 'fullName', {
    get() {
        return `${this.firstName} ${this.lastName}`;
    },
    set(name) {
        [this.firstName, this.lastName] = name.split(' ');
    },
    enumerable: true,
    configurable: true,
});
```

`Object.defineProperties` 메서드를 사용하면 여러 개의 프로퍼티를 한번에 정의할 수 있다.

## 16.5 객체 변경 방지

| 구분 | 메서드 | 프로퍼티 추가 | 프로퍼티 삭제 | 프로퍼티 값 읽기 | 프로퍼티 값 쓰기 | 프로퍼티 어트리뷰트 재정의 |
|---|---|---|---|---|---|---|
| 객체 확장 금지 | `Object.preventExtensions` | X | O | O | O | O |
| 객체 밀봉 | `Object.seal` | X | X | O | O | X |
| 객체 동결 | `Object.freeze` | X | X | O | X | X |

### 16.5.1 객체 확장 금지

`Object.preventExtensions` 메서드는 객체의 확장을 금지한다. 즉, **프로퍼티 추가가 금지**된다. `Object.isExtensible` 메서드로 확장 가능 여부를 확인할 수 있다.

```javascript
const person = { name: 'Lee' };

console.log(Object.isExtensible(person)); // true

Object.preventExtensions(person);

console.log(Object.isExtensible(person)); // false

person.age = 20; // 무시 (strict mode에서는 에러)
delete person.name; // 삭제는 가능
```

### 16.5.2 객체 밀봉

`Object.seal` 메서드는 객체를 밀봉한다. 객체 밀봉이란 프로퍼티 추가, 삭제, 프로퍼티 어트리뷰트 재정의를 금지하는 것이다. 즉, **읽기와 쓰기만 가능**하다. `Object.isSealed` 메서드로 확인할 수 있다.

```javascript
const person = { name: 'Lee' };

Object.seal(person);

console.log(Object.isSealed(person)); // true

person.age = 20;     // 추가 불가 (무시)
delete person.name;  // 삭제 불가 (무시)
person.name = 'Kim'; // 값 갱신은 가능
```

### 16.5.3 객체 동결

`Object.freeze` 메서드는 객체를 동결한다. 객체 동결이란 프로퍼티 추가, 삭제, 프로퍼티 어트리뷰트 재정의, 프로퍼티 값 갱신을 금지하는 것이다. 즉, **읽기만 가능**하다. `Object.isFrozen` 메서드로 확인할 수 있다.

```javascript
const person = { name: 'Lee' };

Object.freeze(person);

console.log(Object.isFrozen(person)); // true

person.age = 20;     // 추가 불가 (무시)
delete person.name;  // 삭제 불가 (무시)
person.name = 'Kim'; // 값 갱신 불가 (무시)
```

### 16.5.4 불변 객체

위의 변경 방지 메서드들(`Object.preventExtensions`, `Object.seal`, `Object.freeze`)은 **얕은(shallow) 변경 방지**로, 직속 프로퍼티만 변경이 방지되고 **중첩 객체까지는 영향을 주지 못한다.**

중첩 객체까지 동결하여 완전한 불변 객체를 만들려면 객체를 값으로 갖는 모든 프로퍼티에 대해 **재귀적으로 `Object.freeze`를 호출**해야 한다.

```javascript
function deepFreeze(target) {
    if (target && typeof target === 'object' && !Object.isFrozen(target)) {
        Object.freeze(target);
        Object.keys(target).forEach(key => deepFreeze(target[key]));
    }
    return target;
}

const person = {
    name: 'Lee',
    address: { city: 'Seoul' }
};

deepFreeze(person);

console.log(Object.isFrozen(person));         // true
console.log(Object.isFrozen(person.address));  // true

person.address.city = 'Busan'; // 무시
console.log(person.address.city); // Seoul
```
