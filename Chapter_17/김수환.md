# 17장 생성자 함수에 의한 객체 생성

## 17.1 Object 생성자 함수

new 연산자와 함께 Object 생성자 함수를 호출하면 빈 객체를 생성하여 반환한다.

```javascript
// 생성
const person = new Object();
// 프로퍼티 추가
person.name = "Lee";
person.sayHello = function () {
  console.log("Hello " + this.name);
};
person.sayHello(); // Hello Lee
```

- **생성자 함수**: new 연산자와 함께 호출하여 객체를 생성하는 함수
- **빌트인 생성자 함수**: String, Number, Boolean, Function, Array, Date, RegExp, Promise 등

## 17.2 생성자 함수

### 17.2.1 객체 리터럴에 의한 객체 생성 방식의 문제점

동일한 프로퍼티를 갖는 객체를 여러 개 생성해야 하는 경우 매번 같은 프로퍼티를 기술해야 하기 때문에 비효율적이다.

### 17.2.2 생성자 함수에 의한 객체 생성 방식의 장점

프로퍼티 구조가 동일한 객체 여러 개를 간편하게 생성할 수 있다.

```javascript
function Circle(radius) {
  this.radius = radius;
  this.getDiameter = function () {
    return 2 * this.radius;
  };
}
const circle1 = new Circle(5); // radius가 5인 Circle 객체 생성
console.log(circle1.getDiameter()); // 10
```

**this**: 객체 자신의 프로퍼티나 메서드를 참조하기 위한 자기 참조 변수. this 바인딩은 함수 호출 방식에 따라 동적으로 결정된다.

| 함수 호출 방식 | this가 가리키는 값 |
| --- | --- |
| 일반 함수로서 호출 | 전역 객체 |
| 메서드로서 호출 | 메서드를 호출한 객체 |
| 생성자 함수로서 호출 | 생성자 함수가 생성할 인스턴스 |

new 연산자를 사용하지 않으면 일반 함수로 동작한다.

### 17.2.3 생성자 함수의 인스턴스 생성 과정

생성자 함수의 역할은 **인스턴스를 생성**하는 것과 **인스턴스를 초기화**(인스턴스 프로퍼티 추가 및 초기값 할당)하는 것이다. (인스턴스 생성은 필수, 초기화는 옵션)

new 연산자와 함께 생성자 함수를 호출하면 자바스크립트 엔진은 다음 과정을 거쳐 암묵적으로 인스턴스를 생성하고 초기화한 후 인스턴스를 반환한다.

#### 1. 인스턴스 생성과 this 바인딩

생성자 함수에 의해 암묵적으로 빈 객체가 생성된다. 그리고 인스턴스는 this에 바인딩된다. (this가 인스턴스를 가리키는 이유, 런타임 이전에 실행)

> **바인딩**: 식별자와 값을 연결하는 과정

```javascript
function Circle(radius) {
  // 암묵적으로 인스턴스가 생성되고 this에 바인딩됨
  console.log(this); // Circle {}
  this.radius = radius;
  this.getDiameter = function () {
    return 2 * this.radius;
  };
}
```

#### 2. 인스턴스 초기화

this에 바인딩되어 있는 인스턴스에 프로퍼티나 메서드를 추가하고, 생성자 함수가 인수로 전달받은 초기값을 인스턴스 프로퍼티에 할당하여 초기화하거나 고정값을 할당한다.

#### 3. 인스턴스 반환

생성자 함수 내부에서 모든 처리가 끝나면 완성된 인스턴스가 바인딩된 this를 암묵적으로 반환한다.

```javascript
function Circle(radius) {
  this.radius = radius;
  this.getDiameter = function () {
    return 2 * this.radius;
  };
  // this를 암묵적으로 반환
}
// 인스턴스 생성. Circle 생성자 함수는 this를 반환
const circle = new Circle(1);
```

- 명시적으로 **객체**를 반환하면 암묵적인 this 반환이 무시된다.
- 명시적으로 **원시 값**을 반환하면 원시 값 반환은 무시되고 암묵적으로 this를 반환한다.
- 명시적으로 this가 아닌 다른 값 반환은 지양해야 한다.

### 17.2.4 내부 메서드 [[Call]], [[Construct]]

- **생성자 함수로서 호출**: new 연산자와 함께 호출하여 객체를 생성하는 것을 의미
- 함수와 객체의 **같은 점**: 프로퍼티와 메서드를 소유할 수 있다.
- 함수와 객체의 **다른 점**: 함수는 호출할 수 있지만 객체는 호출할 수 없다.

> `함수()` → [[Call]] 호출
> `new 함수()` → [[Construct]] 호출
> 함수는 무조건 callable이고, constructor인 함수만 생성자 함수로 사용 가능. 함수는 non-constructor일 수 있다.

### 17.2.5 constructor와 non-constructor의 구분

- **constructor**: 함수 선언문, 함수 표현식, 클래스
- **non-constructor**: 메서드(축약 표현), 화살표 함수

```javascript
// 일반 함수로 정의된 것만이 constructor다
function foo() {}
const bar = function () {};
const baz = { x: function () {} };

// non-constructor (TypeError 발생)
const arrow = () => {};
const obj = {
  x() {}, // 메서드 축약 표현
};
```

ECMAScript 사양에서 메서드란 **ES6의 메서드 축약 표현만을 의미**한다.

일반 함수에 new 연산자를 붙여 호출하면 생성자 함수처럼 동작할 수 있다.

### 17.2.6 new 연산자

- new 연산자와 함께 호출하면 생성자 함수로 동작 → [[Construct]]가 호출됨 (constructor여야 함)
- new 연산자 없이 호출하면 일반 함수로 동작 → [[Call]]이 호출됨

```javascript
function Circle(radius) {
  this.radius = radius;
  this.getDiameter = function () {
    return 2 * this.radius;
  };
}

// new 연산자 없이 호출 (일반 함수로서 호출)
const circle = Circle(5);
console.log(circle); // undefined
console.log(radius); // 5 (전역 객체에 바인딩)
console.log(getDiameter()); // 10
// circle.getDiameter() → TypeError (circle은 undefined)
```

일반 함수로서 호출되었기 때문에 this는 전역 객체 window를 가리킨다.
생성자 함수가 new 연산자 없이 호출되는 것을 방지하기 위해 **파스칼 케이스 컨벤션**을 사용해야 한다.

### 17.2.7 new.target

파스칼 케이스 컨벤션을 사용해도 실수가 생길 수 있다. → ES6에서 `new.target` 지원

- new와 함께 생성자 함수로서 호출되면 함수 내부의 `new.target`은 **함수 자신**을 가리킨다.
- new 연산자 없이 일반 함수로서 호출된 함수 내부의 `new.target`은 **undefined**다.

```javascript
function Circle(radius) {
  if (!new.target) {
    return new Circle(radius);
  }
  this.radius = radius;
  this.getDiameter = function () {
    return 2 * this.radius;
  };
}

// new 연산자 없이 호출하여도 new.target을 통해 생성자 함수로서 호출된다
const circle = Circle(5);
```

- new 연산자와 함께 생성자 함수에 의해 생성된 객체는 **프로토타입**에 의해 생성자 함수와 연결된다. (프로토타입에 대해 19장에서 자세히 다룸)
- 빌트인 생성자 함수는 new 연산자와 함께 호출되었는지 확인 후 적절한 값을 반환한다.
  - **Object, Function, Array 등**: new 없이 호출해도 new와 함께 호출한 것과 동일하게 동작한다.
  - **String, Number, Boolean**: new 없이 호출하면 객체를 생성하는 것이 아니라 **원시 값을 반환**한다. (타입 변환에 활용)

```javascript
const str = String(123);     // "123" (문자열 원시 값)
const num = Number("123");   // 123 (숫자 원시 값)
const bool = Boolean(1);     // true (불리언 원시 값)

const strObj = new String(123);   // String {"123"} (String 객체)
const numObj = new Number("123"); // Number {123} (Number 객체)
```
