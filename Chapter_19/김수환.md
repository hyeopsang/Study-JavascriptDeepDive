# 19장 프로토타입
자바스크립트는 객체 기반의 프로그래밍 언어이며 자바스크립트를 이루고 있는 거의 모든 것이 객체다 원시 값을 제외한 나머지 값들은 객체다
## 19.1 객체지향 프로그래밍
객체지향 프로그래밍은 실체를 인식하는 철학적 사고를 프로그래밍에 접목시킨 것
특징이나 성질을 나타내는 **속성**을 가지고 있다
속성중에 필요한 속성만 간추려 표현하는 것을 **추상화**라고한다
```javascript
const person={
    name:"lee",
    address:'seoul'
}
```
**속성을 통해 여러 개의 값을 하나의 단위로 구성한 복합적인 자료구로를 객체라한다**
```javascript
const circle ={
    radius:5 ,
    getDiameter(){
        return 2*this.radius;
    }
}

```
radius는 상태를 나타내는 데이터이며 지름은 
**객체는 상태 데이터와 동작을 하나의 논리적인 단위로 묶은 복합적인 자료구조**
## 19.2 상속과 프로토타입
상속은 어떤 객체의 프로퍼티 또는 메서드를 다른 객체가 상속받아 사용할 수 있는 것을 말한다
상속을 통해 불필요한 중복을 제거할 수 있다. **자바스크립트는 프로토타입을 기반으로 상속을 구현한다**
```javascript
function Circle(radius){
    this.radius = radius
}
// Circle 생성자 함수가 생성한 모든 인스턴스가 getArea 메서드를
// 공유해서 사용할 수 있도록 프로토타입에 추가한다
// 프로토타입은 Circle 생성자 함수의 prototype 프로퍼티에 바인딩되어 있다
Circle.prototype.getArea=function(){
    return Math.PI*this.raduis **2;
}
const circle1 = new Circle(1)
const circle2 = new Circle(2)
// Circle 생성자 함수가 생성한 모든 인스턴스는 부모 객체의 역할을 하는
// 프로토 타입 Circle.prototype으로부터 getArea 메서드를 상속받는다
console.log(circle1.getArea === circle2.getArea)
```
getArea 메서드는 하나만 생성되어 Circle.prototype의 메서드로 할당되어 있다. CIrcle생성자 함수가 생성하는 인스턴스는 getArea 메서드를 상속받아 사용할 수 있다.

## 19.3 프로토타입 객체
모든 객체는 [[Prototype]]이라는 내부 슬롯을 가진다
이 내부 슬롯의 값은 참조이며 객체 생성 방식에 의해 결정된다
모든 객체는 하나의 프로토타입을 갖는다
### 19.3.1 __proto__ 접근자 프로퍼티
__proto__ 접근자 프로퍼티를 통해 [[Prototype]] 내부 슬롯에 간접적을 접근할 수 있다
__proto__ 접근자 프로퍼티 이므로 [[Get]],[[Set]] 프로퍼티 어트리뷰트로 구성된 프로퍼티다
__proto__ 접근자 프로퍼티는 상속을 통해 사용된다 Object.prototype.__proto__접근자 프로퍼티를 사용할 수 있다
__proto__ 접근자 프로퍼티를 통해 프로퍼티에 접근하는 이유는 상호 참조에 의해 프로토 타입 체인이 생성되는 것을 방지하기 위해서다
__proto__ 접근자 프로퍼티는 모든객체가 사용할 수 있는것은 아니기에 직접 사용하는것이 권장되지 않는다

### 19.3.2 함수 객체의 prototype 프로퍼티
함수 객체만이 가지고 있는 prototype 프로퍼티는 함수 객체가 생성자로 사용될 때, 이 함수를 통해 생성된 객체의 부모 역할을 하는 프로토타입을 가리킨다
화살표함수와 ES6 메서드 축약 표현으로 정의한 메서드는 prototype 프로퍼티를 소유하지 않으며 프로토타입도 생성하지 않는다
모든 객체가 가지고 있는(Object.prototype으로브터 상속븓은)__proto__ 접근자 프로퍼티와 함수 객체만이 가지고 있는 prototype 프로퍼티는 결국 동일한 프로토타입을 가리키지만 주체가 다르다

구분|소유|값|사용주체|사용목적
__proto__접근자 프로퍼티|모든객체|프로토타입의 참조|모든객체|객체가 자신의 프로토타입에 접근 또는 교체하기 위해 사용
prototype 프로퍼티 |constructor|프로토타입으 참조|생성자함수|생성자 함수가 자신이 생성할 객체의 프로토타입을 할당하기 위해 사용
### 19.3.3 프로토타입의 constructor 프로퍼티와 생성자 함수
모든 프로토 타입은 constructor 프로퍼티를 갖는다. 이 constructor 프로퍼티는 객체의 입장에서 자신을 생성할 객체를 가리킨다
```javascript
function Person(name) {
	this.name = name;
}
const me = new Person("Lee");
// me 객체를 생성한 객체는 Person 생성자 함수이다
console.log(me.constructor === Person); // true
```
me 객체는constructor 프로퍼티가 없지만 me 객체의 프로토타입인 Person.prototype에는 constructor 프로퍼티가 있어 me 객체는 프로토타입인 Person.prototype의 constructor 프로퍼티를 상속받아 사용할 수 있다
## 19.4 리터럴 표기법에 의해 생성된 객체의 생성자 함수와 프로토타입
constructor 프로퍼티가 가리키는 생성자 함수는 인스턴스를 생성한 생성자 함수다 (자신을 누가 만들었는지 알수 잇다)

리터럴로 생성한 객체도 프로토타입과 constructor가 존재한다
```javascript
const obj = {};
obj.constructor === Object // true

const arr = [1, 2, 3];
arr.constructor === Array  // true

const fn = function() {};
fn.constructor === Function // true
```

리터럴 표기법|생성자 함수|프로토타입
---|---|---
객체 리터럴 `{}`|Object|Object.prototype
배열 리터럴 `[]`|Array|Array.prototype
함수 리터럴 `function(){}`|Function|Function.prototype
정규 표현식 리터럴 `//`|RegExp|RegExp.prototype

리터럴로 생성된 객체의 생성자 함수를 해당 생성자 함수로 봐도 무방

## 19.5 프로토타입의 생성 시점
모든 객체는 생성자 함수와 연결되어 있다.
프로토타입은 생성자 함수가 생성되는 시점에 생성된다
프로토타입과 생성자 함수는  언제나 쌍으로 존재하기 때문
생성자 함수는 사용자 정의 생성자 함수와 빌트인 생성자 함수로 구분

### 19.5.1 사용자 정의 생성자 함수와 프로토타입 생성 시점
화살표 함수나 ES6의 메서드 축약표현으로 정의 하지 않은 함수 객체는 new 연산자와 함꼐 생성자 함수로서 호출할 수 있다
constructor는 함수 정의가 평가되어 함수 객체를 생성하는 시점에 프로토타입도 생성된다
생성된 프로토타입의 프로토타입은 Object.prototype이다
### 19.5.2 빌트인 생성자 함수와 프로토타입 생성 시점
빌트인 생성자 함수도 일반 함수와 마찬가지로 빌트인 생성자 함수가 생성되는 시점에 프로토타입 이 생긴다
모든 빌트인 함수는 전역객체가 생성되는 시점에 생성된다
객체가 생성되기전에 생성자 함수와 프로토타입은 객체화되어 있지만 리터럴 표기법으로 객체를 생성하면 프로토타입은 생성된 [[Prototype]] 내부슬롯에 할당된다
## 19.6 객체 생성 방식과 프로토타입의 결정
모든 객체는 세부적인 차이가 있지만 추상 연산OrdinaryOnjectCreate에 의해 생성된다
프로토타입은 추상 연산에 전달되는 인수에 의해 결정된다
### 19.6.1 객체 리터럴에 의해 생성된 객체의 프로토타입

자바스크립트 엔진은 객체 리터럴을 평가하여 추상 연산 OrdinaryObjectCreate를 호출한다. 이때 추상 연산에 전달되는 프로토타입은 Object.prototype이다

const obj = { x: 1 };

obj 객체는 object.prototype을 가지며 상속받는다
obj 객체는 constructor 프로퍼티와 hasOwnProperty 에서드를 소유하지 않지만 object.prototype에 의해 사용할 수 있다
### 19.6.2 Object 생성자 함수에 의해 생성된 객체의 프로토타입
Object 생성자 함수를 인수 없이 호출하여 빈 객체를 생성하는 경우에도 객체 리터럴과 동일하게 추상 연산 OrdinaryObjectCreate가 호출된다 이때 전달되는 프로토타입도 Object.prototype이다

### 19.6.3 생성자 함수에 의해 생성된 객체의 프로토타입
생성자 함수를 new 연산자와 함께 호출하여 인스턴스를 생성하는 경우에도 마찬가지로 추상 연산 OrdinaryObjectCreate가 호출된다

```javascript
function Person(name) {
this.name = name;
}
// 프로토타입 메서드
Person.prototype.sayHello = function () {
console.log(`Hi! My name is ${this.name}`);
};
const me = new Person('Lee');
const you = new Person('Kim');
me.sayHello(); // Hi! My name is Lee
you.sayHello(); // Hi! My name is Kim
```

쉽게 말해서:
- Person이라는 틀(생성자 함수)을 만든다
- 그 틀에 sayHello라는 기능을 붙여놓는다 (prototype에 추가)
- me, you는 그 틀로 찍어낸 객체들
- me, you 둘 다 sayHello를 직접 갖고 있진 않지만, Person.prototype에 있으니까 빌려서 쓸 수 있다
- 결과: 메모리 절약 + 모든 인스턴스가 같은 메서드 공유
## 19.7 프로토타입 체인
프로토타입 체인은 자바스크립트에서 객체지향 프로그래밍의 상속을 구현하는 메커니즘이다 자바스크립트 엔진은 객체의 프로퍼티(메서드 포함)에 접근하려고 할 때, 해당 객체에 접근하려는 프로퍼티가 없다면 [[Prototype]] 내부 슬롯의 참조를 따라 자신의 부모 역할을 하는 프로토타입의 프로퍼티를 순차적으로 검색한다
프로토타입의 프로토타입은 언제나 Object.prototype이며 프로토타입 체인의 종점이라고 한다 따라서 모든 객체는 Object.prototype을 상속받는다
Object.prototype의 프로토타입, 즉 [[Prototype]] 내부 슬롯의 값은 null이다

스코프 체인은 식별자 검색을 위한 메커니즘이다 자바스크립트 엔진은 함수의 중첩 관계로 이루어진 스코프의 계층적 구조에서 식별자를 검색한다

## 19.8 오버라이딩과 프로퍼티 섀도잉
```javascript
const Person = (function () {
  // 생성자 함수
  function Person(name) {
    this.name = name;
  }
 
  // 프로토타입 메서드
  Person.prototype.sayHello = function () {
    console.log(`Hi! My name is ${this.name}`);
  };
 
  // 생성자 함수를 반환
  return Person;
}());
 
const me = new Person('Lee');
 
// 인스턴스 메서드
me.sayHello = function () {
  console.log(`Hey! My name is ${this.name}`);
};
 
// 인스턴스 메서드가 호출된다. 프로토타입 메서드는 인스턴스 메서드에 의해 가려진다.
me.sayHello(); // Hey! My name is Lee
```
인스턴스 메서드 sayHello는 프로토타입 메서드 sayHello를 오버라이딩했고 프로토타입 메서드 sayHello는 가려진다

프로퍼티 섀도잉:상속 관계에 의해 프로퍼티가 가려지는 현상
오버라이딩:상위 클래스가 가지고 있는 메서드를 하위 클래스가 재정의하여 사용하는 방식

```javascript
// 인스턴스 메서드를 삭제 
delete me.sayHello;
 
// 인스턴스에는 sayHello 메서드가 없으므로 프로토타입 메서드가 호출
me.sayHello(); // Hi! My name is Lee
```
프로토타입 메서드가 아닌 인스턴스 메서드 sayHello가 삭제되고 다시 시도해도 프로토타입 메서드가 삭제되지 않는다

```javascript
// 프로토타입 메서드 변경
Person.prototype.sayHello = function () {
  console.log(`Hey! My name is ${this.name}`);
};
me.sayHello(); // Hey! My name is Lee
 
// 프로토타입 메서드 삭제
delete Person.prototype.sayHello;
me.sayHello(); // TypeError: me.sayHello is not a function

```
프로토타입 프로퍼티를 변경 또는 삭제하려면 하위 객체를 통해 프로토타입 체인으로 접근하는 것이 아니라 프로토타입에 직접 접근해야 한다

## 19.9 프로토타입의 교체
### 19.9.1 생성자 함수에 의한 프로토타입의 교체
```javascript
const Person = (function () {
  function Person(name) {
    this.name = name;
  }
 
  // 생성자 함수의 prototype 프로퍼티를 통해 프로토타입을 교체
  Person.prototype = {
    sayHello() {
      console.log(`Hi! My name is ${this.name}`);
    }
  };
 
  return Person;
}());
 
const me = new Person('Lee');
```
프로토타입으로 교체한 객체 리터럴에는 constructor프러포터기 없다 자바스크립트엔진이 암묵적으로 추가한거여서 me 객체의 생성자 함수를 검색하면 Person이 아닌 Object가 나온다

```javascript
// 프로토타입을 교체하면 constructor 프로퍼티와 생성자 함수 간의 연결이 파괴된다.
console.log(me.constructor === Person); // false
// 프로토타입 체인을 따라 Object.prototype의 constructor 프로퍼티가 검색된다.
console.log(me.constructor === Object); // true

const Person = (function () {
  function Person(name) {
    this.name = name;
  }
 
  // 생성자 함수의 prototype 프로퍼티를 통해 프로토타입을 교체
  Person.prototype = {
    // constructor 프로퍼티와 생성자 함수 간의 연결을 설정
    constructor: Person,
    sayHello() {
      console.log(`Hi! My name is ${this.name}`);
    }
  };
 
  return Person;
}());
 
const me = new Person('Lee');
 
// constructor 프로퍼티가 생성자 함수를 가리킨다.
console.log(me.constructor === Person); // true
```
프로토타입으로 교체한 객체 리터럴레 constructor 프로퍼티를 추가하여 프로토타입의 constructor 프로퍼티를 되살릴수있다
### 19.9.2 인스턴스에 의한 프로토타입의 교체
프로토타입은 생성자 함수의 prototype 프로퍼티뿐만 아니라 인스턴스의 proto 접근자 프로퍼티(또는 Object.getPrototypeOf 메서드)를 통해 접근할 수 있어서  proto 접근자 프로퍼티를 통해 프로토타입을 교체할 수 있다

**생성자 함수 vs 인스턴스에 의한 프로토타입 교체 차이점**

| 구분 | 생성자 함수에 의한 교체 | 인스턴스에 의한 교체 |
|---|---|---|
| Person.prototype | 새 객체를 가리킴 | 원래 객체 그대로 |
| 영향 범위 | 이후 모든 인스턴스 | 해당 인스턴스만 |
| 연결 | 생성자 ↔ 프로토타입 연결 유지 | 생성자 ↔ 프로토타입 연결 끊김 |

```
생성자 함수에 의한 교체:
Person.prototype ──→ 새 프로토타입
                          ↑
me.__proto__ ────────────┘  (둘 다 새 프로토타입)

인스턴스에 의한 교체:
Person.prototype ──→ 원래 프로토타입 (그대로)
me.__proto__ ──→ 새 프로토타입 (따로 논다)
```
## 19.10 instanceof 연산자
instanceof 연산자는 이항 연산자로서 좌변에는 객체를 가리키는 식별자, 우변에는 생성자 함수를 가리키는 식별자를 피연산자로 받는다. 만약 우변의 피연산자가 함수가 아니면 TypeError가 발생한다.

instanceof 연산자는 우변의 생성자 함수의 prototype에 바인딩된 객체가 좌변의 객체의 프로토타입 체인 상에 존재하면 true로 평가되고, 그렇지 않으면 false로 평가된다.

우변의 생성자 함수의 prototype에 연결된 객체가 좌변의 프로토타입 체인상에 존재하는지 판단하는것

```javascript
const Person = (function () {
  function Person(name) {
    this.name = name;
  }
 
  // 생성자 함수의 prototype 프로퍼티를 통해 프로토타입을 교체
  Person.prototype = {
    sayHello() {
      console.log(`Hi! My name is ${this.name}`);
    }
  };
 
  return Person;
}());
 
const me = new Person('Lee');
 
// constructor 프로퍼티와 생성자 함수 간의 연결은 파괴되어도 instanceof는 아무런 영향을 받지 않는다.
console.log(me.constructor === Person); // false
 
// Person.prototype이 me 객체의 프로토타입 체인 상에 존재하므로 true로 평가된다.
console.log(me instanceof Person); // true
// Object.prototype이 me 객체의 프로토타입 체인 상에 존재하므로 true로 평가된다.
console.log(me instanceof Object); // true
```
## 19.11 직접 상속
### 19.11.1 Object.create에 의한 직접 상속
Object.create는 프로토타입을 직접 지정해서 새 객체를 만드는 메서드
Object.create의 첫번째 매개변수는 생성할 객체의 프로토타입으로 지정할 객체 두번째 매개변수는 생성할 객체의 프로퍼티키와 프로퍼티 디스크립터 객체로 이뤄진객체를 전달(옵션이라 생략가능)

```javascript
// 프로토타입이 null인 객체를 생성한다. 생성된 객체는 프로토타입 체인의 종점에 위치한다.
// obj → null
let obj = Object.create(null);
console.log(Object.getPrototypeOf(obj) === null); // true
// Object.prototype을 상속받지 못한다.
console.log(obj.toString()); // TypeError: obj.toString is not a function
 
// obj → Object.prototype → null
// obj = {};와 동일하다.
obj = Object.create(Object.prototype);
console.log(Object.getPrototypeOf(obj) === Object.prototype); // true
 
// obj → Object.prototype → null
// obj = { x: 1 };와 동일하다.
obj = Object.create(Object.prototype, {
  x: { value: 1, writable: true, enumerable: true, configurable: true }
});
 
const myProto = { x: 10 };
// 임의의 객체를 직접 상속받는다.
// obj → myProto → Object.prototype → null
obj = Object.create(myProto);
console.log(obj.x); // 10
console.log(Object.getPrototypeOf(obj) === myProto); // true
 
// 생성자 함수
function Person(name) {
  this.name = name;
}
 
// obj → Person.prototype → Object.prototype → null
// obj = new Person('Lee')와 동일하다.
obj = Object.create(Person.prototype);
obj.name = 'Lee';
console.log(obj.name); // Lee
console.log(Object.getPrototypeOf(obj) === Person.prototype); // true
```
장점:
- new 연산자 없이도 객체 생성 가능
- 프로토타입을 직접 지정 가능
- null을 넘기면 프로토타입 체인 종점에 있는 순수한 객체 생성 가능
### 19.11.2 객체 리터럴 내부에서 __proto__에 의한 직접 상속
```javascript

const myProto = { x: 10 };
 
// 객체 리터럴에 의해 객체를 생성하면서 프로토타입을 지정하여 직접 상속받을 수 있다.
const obj = {
  y: 20,
  // 객체를 직접 상속받는다.
  // obj → myProto → Object.prototype → null
  __proto__: myProto
};
 
console.log(obj.x, obj.y); // 10 20
console.log(Object.getPrototypeOf(obj) === myProto); // true
```
ES6에서는 객체 리터럴 내부에서 __proto__ 접근자 프로퍼티를 사용하여 직접 상속을 구현할 수 있다.
## 19.12 정적프로퍼티/메서드
정적프로퍼티/메서드:생성자 함수로 인스턴스를 생성하지 않아도 참조/호출할 수 있는 프로퍼티/메서드
```javascript
// 생성자 함수
function Person(name) {
  this.name = name;
}
 
// 프로토타입 메서드
Person.prototype.sayHello = function () {
  console.log(`Hi! My name is ${this.name}`);
};
 
// 정적 프로퍼티
Person.staticProp = 'static prop';
 
// 정적 메서드 
Person.staticMethod = function () {
  console.log('staticMethod');
};
 
const me = new Person('Lee');
 
// 생성자 함수로 호출
Person.staticMethod(); // staticMethod
 
// 인스턴스로 호출 불가능
me.staticMethod(); // TypeError: me.staticMethod is not a function
```
정적 프로퍼티/메서드는 생성자 함수가 생성한 인스턴스로 참조/호출할 수 없다
## 19.13 프로퍼티 존재 확인
### 19.13.1 in 연산자
in 연산자는 객체 내에 특정 프로퍼티가 존재하는지 여부를 확인한다

``` javascript
// key: 프로퍼티 키를 나타내는 문자열
// object: 객체로 평가되는 표현식
key in object
```
확인 대상 객체가 상속받은 모든 프로토타입의 프로퍼티까지 확인하기 때문에 주의

### 19.3.2 Object.prototype.hasOwnPropery 메서드

Object.prototype.hasOwnPropery 메서드를 사용하여 객체에 특정 프로퍼티가 존재하는지 확인할수 있음
인수로 전달받은 프로퍼티 키가 객체 고유의 프로퍼티 키인 경우에만 true를 반환하고, 상속받은 프로토타입의 프로퍼티 키인 경우에는 false를 반환
## 19.14 프로퍼티 열거
### 19.14.1 for...in 문
객체의 모든 프로퍼티를 순회하며 열거할 때는 for...in 문을 사용 Object.prototype의 프로퍼티는 열거하지 않음  프로퍼티 어트리뷰트 [[Enumerable]]의 값이 false이기 때문
for...in 문은 객체의 프로토타입 체인 상에 존재하는 모든 프로토타입의 프로퍼티 중에서 프로퍼티 어트리뷰트 [[Enumerable]]의 값이 true인 프로퍼티만을 순회하며 열거

for...in 문은 프로퍼티 키가 심벌인 프로퍼티는 열거하지 않는다
상속받은 프로퍼티는 제외하고 객체 자신의 프로퍼티만 열거하려면 Object.prototype.hasOwnPropery 메서드를 사용하여 객체 자신이 프로퍼티인지 확인해야한다

프로퍼티 순서를 보장하지 않지만 대부분 모던 브라우저는 순서를 보장하고 프로퍼티 키에 대해 정렬도 실시함

### 19.14.2 Object.keys/values/entries 메서드
객체 자신의 고유 프로퍼티만 열거하기 위해서는 for...in 문보다는 Object.keys/values/entries 메서드의 사용을 권장

```javascript
const person = {
  name: 'Kim',
  address: 'Seoul',
  __proto__: { age: 20 }
};

console.log(Object.keys(person));  // ["name", "address"]
console.log(Object.values(person));  // ["Kim", "Seoul"]
console.log(Object.entries(person));  // [["name", "Kim"], ["address", "Seoul"]]
```
