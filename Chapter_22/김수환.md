# 22장 this

## 22.1 this 키워드

this: 자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 자기 참조 변수
this 바인딩은 함수 호출 방식에 따라 동적으로 결정된다

> 바인딩이란 식별자와 값을 연결하는 것. this 바인딩은 this가 가리킬 객체를 바인딩하는 것

```javascript
// 1. 객체 메서드 → this는 호출한 객체
const circle = {
  radius: 5,
  getDiameter() {
    return 2 * this.radius; // this = circle
  },
};

// 2. 생성자 함수 → this는 생성할 인스턴스
function Circle(radius) {
  this.radius = radius; // this = 새로 만들 인스턴스
}

// 3. 전역 → this는 전역 객체
console.log(this); // window
```

this는 객체 메서드 내부 또는 생성자 함수 내부에서만 의미가 있다
strict mode에서 일반 함수의 this는 undefined

## 22.2 함수 호출 방식과 this 바인딩

**this 바인딩은 함수 호출 방식에 따라 동적으로 결정된다**

렉시컬 스코프 vs this 바인딩:

- 렉시컬 스코프: 함수 **정의** 시점에 상위 스코프 결정
- this 바인딩: 함수 **호출** 시점에 결정

### 22.2.1 일반 함수 호출

일반 함수로 호출하면 this에는 전역 객체(window)가 바인딩된다

```javascript
function foo() {
  console.log(this); // window (strict mode: undefined)
}
```

메서드 내부의 중첩 함수도 일반 함수로 호출되면 전역 객체가 바인딩된다

```javascript
var value = 1;
const obj = {
  value: 100,
  foo() {
    console.log(this.value); // 100 (this = obj)
    function bar() {
      console.log(this.value); // 1 (this = window)
      // 중첩함수도 일반함수로 호출되면 전역객체 바인딩
    }
    bar();
  },
};
```

### 22.2.2 메서드 호출

메서드 내부의 this는 메서드를 호출한 객체가 바인딩된다

```javascript
const person = {
  name: "Lee",
  getName() {
    return this.name;
  },
};
console.log(person.getName()); // 'Lee'
```

this에 바인딩될 객체는 호출 시점에 결정된다

```javascript
function Person(name) {
  this.name = name;
}
Person.prototype.getName = function () {
  return this.name;
};
const me = new Person("Lee");
console.log(me.getName()); // 'Lee' ← me가 호출했으니 this = me
Person.prototype.name = "Kim";
console.log(Person.prototype.getName()); // 'Kim' ← Person.prototype이 호출했으니 this = Person.prototype
```

### 22.2.3 생성자 함수 호출

생성자 함수 내부의 this는 생성할 인스턴스가 바인딩된다

```javascript
function Circle(radius) {
  this.radius = radius;
  this.getDiameter = function () {
    return 2 * this.radius;
  };
}
const circle1 = new Circle(5);
console.log(circle1.getDiameter()); // 10

const circle2 = Circle(5); // new 없이 호출 → 일반 함수
console.log(circle2); // undefined
```

### 22.2.4 Function.prototype.apply/call/bind 메서드에 의한 간접 호출

**apply / call** → this를 지정하면서 함수를 **즉시 호출**
```javascript
function getThisBinding() {
  console.log(this);
}
const thisArg = { a: 1 };

getThisBinding.apply(thisArg, [1, 2, 3]); // { a: 1 } (인수를 배열로 전달)
getThisBinding.call(thisArg, 1, 2, 3);    // { a: 1 } (인수를 쉼표로 전달)
```
apply와 call은 인수 전달 방식만 다를 뿐 동일하게 동작한다
용도: 유사 배열 객체에 배열 메서드를 사용하는 경우
```javascript
function convertArgsToArray() {
  console.log(arguments); // [1, 2, 3] (유사 배열 객체)
  const arr = Array.prototype.slice.call(arguments);
  console.log(arr); // [1, 2, 3] (진짜 배열)
}
convertArgsToArray(1, 2, 3);
```

**bind** → 함수를 호출하지 않고 this만 교체한 **새 함수 반환**
```javascript
function getThisBinding() {
  console.log(this);
}
const thisArg = { a: 1 };

const bound = getThisBinding.bind(thisArg);
console.log(bound);  // function getThisBinding() { ... } (호출 안 됨)
bound();             // { a: 1 } (명시적으로 호출해야 실행)
```
용도: 콜백 함수 내부의 this가 불일치하는 문제를 해결
```javascript
const person = {
  name: 'Lee',
  foo(callback) {
    // bind로 callback의 this를 person으로 고정
    setTimeout(callback.bind(this), 100);
  }
};
person.foo(function () {
  console.log(this.name); // 'Lee'
});
```

| 메서드 | 함수 호출 여부 | 인수 전달 방식 |
|---|---|---|
| apply | O (즉시 호출) | 배열로 전달 |
| call | O (즉시 호출) | 쉼표로 구분하여 전달 |
| bind | X (새 함수 반환) | - |

## this 바인딩 정리표

| 함수 호출 방식   | this 바인딩                                 | 예시                             |
| ---------------- | ------------------------------------------- | -------------------------------- |
| 일반 함수 호출   | 전역 객체 (window) / strict mode: undefined | `foo()`                          |
| 메서드 호출      | 메서드를 호출한 객체                        | `obj.method()` → this = obj      |
| 생성자 함수 호출 | 생성할 인스턴스                             | `new Foo()` → this = 새 인스턴스 |
| apply/call       | 첫 번째 인수로 전달한 객체                  | `fn.call(obj)` → this = obj      |
| bind             | 첫 번째 인수로 전달한 객체                  | `fn.bind(obj)()` → this = obj    |
| 화살표 함수      | 상위 스코프의 this (정적 결정)              | 호출 방식과 무관                 |
