# 24장 클로저

함수가 생성될 때 렉시컬 스코프를 기억하여, 함수가 외부에서 호출되어도 그 환경에 접근할 수 있는 기능. 주로 전역 변수 사용을 억제하기 위한 데이터 은닉화나, 이전 상태를 안전하게 유지해야 하는 상황에서 활용한다.

```javascript
const x = 1;
function outerFunc() {
  const x = 10;
  function innerFunc() {
    console.log(x); // 10
  }
  innerFunc();
}
outerFunc();
```

## 24.1 렉시컬 스코프

**렉시컬 스코프(정적 스코프)**: 함수를 어디서 호출했는지가 아니라 어디서 정의했는지에 따라 상위 스코프를 결정한다.

상위 스코프에 대한 참조는 함수 정의가 평가되는 시점에 함수가 정의된 환경에 의해 결정된다.

## 24.2 함수 객체의 내부 슬롯 [[Environment]]

내부 슬롯 `[[Environment]]`에 자신이 정의된 환경을 저장한다. (상위 스코프 참조)

외부 렉시컬 환경에 대한 참조에는 함수 객체의 내부 슬롯 `[[Environment]]`에 저장된 렉시컬 환경의 참조가 할당된다.

```javascript
function outer() {
  const x = 10; // 부모의 렉시컬 환경에 있는 변수
  function inner() {
    // 1. 정의(평가) 시점: 현재 실행 중인 outer의 렉시컬 환경을 [[Environment]]에 저장
    console.log(x); // 2. 실행 시점: [[Environment]]를 통해 부모의 변수 x에 접근
  }
  return inner; // 3. 부모의 환경을 쥐고 있는 inner를 밖으로 내보냄
}
const myFunc = outer(); // outer 실행 컨텍스트는 여기서 종료(삭제)
myFunc(); // 4. 하지만 x=10이 출력됨 (클로저)
```

## 24.3 클로저와 렉시컬 환경

```javascript
const x = 1;
function outer() {
  const x = 10;
  const inner = function () {
    console.log(x);
  };
  return inner;
}
const innerFunc = outer();
innerFunc(); // 10
// outer는 종료되었지만 innerFunc가 outer의 변수 x를 참조하고 있다
```

outer 함수가 종료되면 outer 함수의 실행 컨텍스트는 실행 컨텍스트 스택에서는 사라지지만, 렉시컬 환경은 남아있기 때문에 참조할 수 있다. (가비지 컬렉터의 대상이 되지 않는 이유)

innerFunc를 호출하면 대입받았던 inner 함수가 실행되는데, 내부에 x가 없으므로 자신이 태어날 때 저장해둔 상위 스코프(outer의 환경)로 거슬러 올라가 박제되어 있던 `x = 10`을 참조한다.

### 실행 컨텍스트 vs 렉시컬 환경

| 구분 | 실행 컨텍스트 (Execution Context) | 렉시컬 환경 (Lexical Environment) |
|------|----------------------------------|----------------------------------|
| 핵심 역할 | 실행 관리자. 함수가 실행되는 순서와 흐름(Stack)을 제어한다. | 데이터 저장소. 변수, 함수 선언, 상위 스코프에 대한 참조를 보관한다. |
| 존재 위치 | 콜 스택 (Call Stack) | 힙 (Heap) / 메모리 공간 |
| 생명 주기 | 함수가 호출될 때 생성되고, 종료되면 즉시 파괴된다. | 함수가 종료되어도 누군가 참조하고 있다면 메모리에 유지된다. |
| 주요 구성 | 렉시컬 환경 참조, This 바인딩 등 | 환경 레코드(변수 저장), 외부 환경 참조(상위 스코프 연결) |
| 비유 | 공연 스케줄러. 지금 누가 무대에 올라가야 하는지 결정함. | 대기실/사물함. 배우가 쓸 소품(변수)을 넣어두는 공간. |

### 클로저가 아닌 경우

```javascript
function foo() {
  const x = 1;
  const y = 2;
  function bar() {
    const z = 3;
    debugger;
    console.log(z);
  }
  return bar;
}
const bar = foo();
bar();
// bar가 상위 스코프인 foo의 변수를 참조하지 않아 메모리 낭비 → 클로저 X
```

```javascript
function foo() {
  const x = 1;
  function bar() {
    debugger;
    console.log(x);
  }
  bar();
}
foo();
// bar가 foo의 변수 x를 참조하지만, 리턴하지 않았으므로
// foo가 끝남과 동시에 x도 메모리에서 해제됨 → 클로저 X
```

### 클로저인 경우

```javascript
function foo() {
  const x = 1;
  const y = 2;
  function bar() {
    debugger;
    console.log(x);
  }
  return bar;
}
const bar = foo();
bar();
// bar가 상위 변수 x를 참조하여 엔진의 최적화를 피했고,
// return을 통해 전역 변수에 대입됨으로써 foo보다 오래 살아남아 클로저 O
// x는 외부에서 선언되었지만 내부에서 자유롭게 사용 가능하므로 자유 변수
```

## 24.4 클로저의 활용

클로저는 상태를 안전하게 변경하고 유지하기 위해 사용한다. (정보 은닉)

```javascript
// 문제: num이 호출마다 0으로 초기화
const increase = function () {
  let num = 0;
  return ++num;
};

// 해결: 즉시 실행 함수 + 클로저로 은닉화
const increase = (function () {
  let num = 0;
  return function () {
    return ++num;
  };
})();
console.log(increase()); // 1
console.log(increase()); // 2
console.log(increase()); // 3
```

### 일반 함수 vs 즉시 실행 함수

| 구분 | 일반 함수 (`increase = function...`) | 즉시 실행 함수 (`increase = (function...())`) |
|------|--------------------------------------|----------------------------------------------|
| `num = 0` 실행 횟수 | 호출할 때마다 매번 | 딱 한 번 (초기 설정 시) |
| 호출 시 실행되는 코드 | 함수 전체 (num 선언 포함) | 리턴된 내부 함수만 (`++num`만) |
| 결과 | 항상 1 (초기화의 굴레) | 1, 2, 3... (누적) |

### 고차 함수를 활용한 클로저

```javascript
function Counter(aux) {
  let counter = 0;
  return function () {
    counter = aux(counter);
    return counter;
  };
}
function increase(n) {
  return ++n;
}
function decrease(n) {
  return --n;
}
const increaser = Counter(increase);
console.log(increaser()); // 1
console.log(increaser()); // 2

const decreaser = Counter(decrease);
console.log(decreaser()); // -1
console.log(decreaser()); // -2
// Counter를 실행할 때 전달받은 함수(increase)를 aux에 할당해서 박제해두었기 때문에
// 나중에 언제든 꺼내 쓸 수 있다
```

## 24.5 캡슐화와 정보 은닉

캡슐화는 객체의 상태를 나타내는 프로퍼티와 프로퍼티를 참조하고 조작할 수 있는 동작인 메서드를 하나로 묶는 것 = 정보 은닉

자바스크립트는 접근 제한자가 없어 기본적으로 public 상태이다.

```javascript
const Person = (function () {
  let _age = 0; // 외부에서 접근 불가능한 '박제된' 변수 (Private)

  function Person(name, age) {
    this.name = name; // public
    _age = age;
  }

  // 프로토타입 메서드
  Person.prototype.sayHi = function () {
    console.log(`Hi! My name is ${this.name}. I am ${_age}.`);
  };

  return Person;
})();

const me = new Person("Lee", 20);
me.sayHi(); // Hi! My name is Lee. I am 20.

console.log(me.name); // Lee (접근 가능)
console.log(me._age); // undefined (외부에서 직접 접근 불가!)
```
