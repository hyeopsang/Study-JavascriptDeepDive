# 24장 클로저

## 1. 렉시컬 스코프 (Lexical Scope)

> **"스코프는 함수를 호출한 곳이 아니라, 선언(작성)한 곳에 따라 결정된다."**

자바스크립트는 **정적 스코프(Static Scope)** 방식을 따릅니다. 코드가 작성되는 순간, 각 변수와 함수의 상위 스코프(접근 가능 범위)가 이미 결정되어 변하지 않는다는 뜻입니다.

- **핵심:** 함수가 태어난 곳(작성된 위치)이 곧 그 함수의 '고향'이자 상위 스코프입니다.
- **비교:** 함수를 *어디서 호출했는지*는 스코프 결정에 아무런 영향을 주지 않습니다.

## 2. 연결 고리: 내부 슬롯 `[[Environment]]`

렉시컬 스코프 규칙을 실제로 구현하기 위해 자바스크립트 엔진은 다음과 같은 메커니즘을 사용합니다.

1. **함수 정의 평가:** 엔진이 함수 선언문을 만나면 함수 객체를 생성합니다.
2. **환경 저장:** 이때, "현재 실행 중인 실행 컨텍스트의 렉시컬 환경(자신이 태어난 곳)"을 함수 객체의 내부 슬롯 `[[Environment]]`에 저장합니다.
3. **영구 기억:** 함수는 이 슬롯을 통해 자신이 어디서 태어났는지를 영원히 기억합니다.

## 3. 클로저 (Closure)

> **"외부 함수가 종료되어도, 내부 함수가 외부 함수의 변수를 여전히 참조할 수 있는 현상"**

렉시컬 스코프의 규칙과 `[[Environment]]`의 기억 능력 덕분에 발생하는 특별한 현상입니다.

- **작동 원리:**

1. 외부 함수(`Outer`)가 내부 함수(`Inner`)를 반환하고 종료(Pop)됩니다.
2. 보통은 `Outer`의 변수들이 메모리에서 사라져야 합니다.
3. 하지만 `Inner` 함수의 `[[Environment]]`가 `Outer`의 환경을 참조하고(붙잡고) 있습니다.
4. 가비지 컬렉터(GC)는 누군가 참조하고 있는 메모리는 지우지 않습니다.
5. 결국 `Inner`는 죽어버린 `Outer`의 변수를 계속 사용할 수 있게 됩니다.

## 4. 핵심 질문: 메모리 누수는 없을까?

> **Q. 클로저가 상위 스코프를 계속 잡고 있으면 메모리 낭비 아닌가요?**

**A. 모던 자바스크립트 엔진(V8 등)은 똑똑하게 최적화하므로 괜찮습니다.**

과거에는 상위 스코프 객체를 통째로 유지했지만, 최신 엔진은 **스코프 분석(Scope Analysis)**을 통해 최적화를 수행합니다.

- **클로저 최적화 과정:**

1. 코드를 분석하여 내부 함수가 **실제로 사용하는 변수**만 파악합니다.
2. 사용되는 변수만 남기고, **사용하지 않는 변수는 가비지 컬렉션(GC)** 대상으로 만들어 메모리를 해제합니다.
3. 따라서 불필요한 메모리 점유를 최소화합니다.

## 5. 전체 코드 예시

```javascript
// [1. 렉시컬 스코프]
// 코드를 작성하는 순간, inner의 상위 스코프는 outer로 결정됨
function outer() {
  const x = 10; // 클로저가 사용하는 변수 (유지됨)
  const y = 20; // 클로저가 사용하지 않는 변수 (최적화로 제거됨)
  const hugeData = new Array(1000000); // (메모리 해제됨)

  // [2. [[Environment]] 저장]
  // inner 함수 객체 생성 시, outer의 환경을 [[Environment]]에 저장
  function inner() {
    debugger; // 디버거로 확인 시 Scope에 x만 존재함
    console.log(x);
  }

  return inner;
}

const myClosure = outer();
// outer 함수는 실행을 마치고 스택에서 제거됨(Life Cycle 종료)

// [3. 클로저 실행]
// myClosure(inner)는 [[Environment]]를 통해
// 죽어버린 outer의 변수 x에 접근 가능
myClosure(); // 10
```
