# 26장 ES6 함수의 추가 기능

## 26.1 함수의 구분

ES6 이전의 모든 함수는 일반 함수로서 호출할 수 있고 생성자 함수로서 호출할 수도 있었다.

```javascript
var foo = function () {
  return 1;
};
foo();        // 1 (일반 함수 호출)
new foo();    // foo {} (생성자 함수 호출)
var obj = { foo: foo };
obj.foo();    // 1 (메서드 호출)
```

함수의 목적에 따른 명확한 구분이 없었고, 생성자 함수로 호출하지 않아도 프로토타입 객체를 생성하는 문제가 있었다. 즉, 메서드나 콜백 함수로만 사용할 의도였어도 내부적으로 prototype 프로퍼티를 갖고 프로토타입 객체를 생성하므로 불필요한 메모리 낭비가 발생한다.

ES6에서는 함수의 사용 목적에 따라 세 가지로 명확히 구분한다.

| ES6 함수 구분 | constructor | prototype | super | arguments |
|-------------|:-----------:|:---------:|:-----:|:---------:|
| 일반 함수     | O           | O         | X     | O         |
| 메서드        | X           | X         | O     | O         |
| 화살표 함수   | X           | X         | X     | X         |

## 26.2 메서드

ES6 사양에서 메서드는 **메서드 축약 표현으로 정의된 함수**만을 의미한다.

```javascript
const obj = {
  x: 1,
  // ES6 메서드 축약 표현 → 메서드 O
  foo() {
    return this.x;
  },
  // 일반 함수 방식 → 메서드 X
  bar: function () {
    return this.x;
  },
};

console.log(obj.foo()); // 1
console.log(obj.bar()); // 1
new obj.foo(); // TypeError: obj.foo is not a constructor
new obj.bar(); // bar {}
```

| 함수 형태          | prototype 프로퍼티 | new 생성 가능 | 비고                      |
|------------------|:----------------:|:-----------:|--------------------------|
| `function name() {}` | O              | O           | 전통적인 방식 (무거움)      |
| `methodName() {}`    | X              | X           | ES6 메서드 축약형 (가벼움) |
| `() => {}`           | X              | X           | 화살표 함수               |

ES6 메서드는 자신이 바인딩된 객체를 가리키는 내부 슬롯 `[[HomeObject]]`를 갖는다. `[[HomeObject]]`는 메서드 축약 표현과 클래스 메서드만 가지며, 이를 통해 `super` 키워드로 프로토타입 체인을 참조할 수 있다.

## 26.3 화살표 함수

콜백 함수 내부에서 `this`가 전역 객체를 가리키는 문제를 해결하기 위한 대안으로 ES6에서 도입되었다.

### 26.3.1 화살표 함수 정의

```javascript
// 기본 형태
const add = (x, y) => x + y;

// 매개변수가 하나인 경우 소괄호 생략 가능
const double = x => x * 2;

// 함수 몸체가 표현식이면 중괄호와 return 생략 가능
const square = x => x ** 2;

// 객체 리터럴을 반환하는 경우 소괄호로 감싸야 함
const makeObj = (x, y) => ({ x, y });
```

### 26.3.2 화살표 함수와 일반 함수의 차이

1. 화살표 함수는 인스턴스를 생성할 수 없는 **non-constructor**다.
2. **중복된 매개변수 이름**을 선언할 수 없다.
3. 화살표 함수는 함수 자체의 `this`, `arguments`, `super`, `new.target` **바인딩을 갖지 않는다.** 상위 스코프의 것을 참조한다.

### 26.3.3 this

일반 함수를 콜백으로 사용하면 `this`가 전역 객체(strict mode에서는 `undefined`)를 가리켜 문제가 발생한다.

```javascript
class Prefixer {
  constructor(prefix) {
    this.prefix = prefix;
  }
  add(arr) {
    // 화살표 함수의 this는 상위 스코프(add 메서드)의 this를 참조한다
    return arr.map((item) => this.prefix + item);
  }
}
const prefixer = new Prefixer("-webkit-");
console.log(prefixer.add(["transition", "user-select"]));
// ["-webkit-transition", "-webkit-user-select"]
```

화살표 함수는 함수 자체의 `this` 바인딩을 갖지 않고 상위 스코프의 `this`를 그대로 참조한다. 이를 **lexical this**라고 한다.

```javascript
// 화살표 함수가 중첩되어도 가장 가까운 일반 함수의 this를 참조한다
(function () {
  const bar = () => () => console.log(this);
  bar()(); // { a: 1 }
}).call({ a: 1 });

// 화살표 함수가 전역 함수라면 this는 전역 객체를 가리킨다
const foo = () => console.log(this);
foo(); // window (브라우저) 또는 global (Node.js)
```

화살표 함수를 메서드나 프로토타입 프로퍼티에 할당하면 `this`가 전역 객체를 가리키므로 주의해야 한다.

```javascript
const person = {
  name: "lee",
  // 객체 리터럴은 스코프를 만들지 않아서 this가 전역 객체를 가리킨다
  sayHi: () => console.log(`Hi ${this.name}`), // Hi undefined
};

function Person(name) {
  this.name = name;
}
// 프로토타입 프로퍼티에 화살표 함수를 할당해도 동일한 문제 발생
Person.prototype.sayHi = () => console.log(`Hi ${this.name}`);
const person2 = new Person("Lee");
person2.sayHi(); // Hi undefined
```

클래스 필드에 화살표 함수를 정의하면 인스턴스 메서드가 되므로, **메서드는 축약 표현으로 정의하는 것이 좋다.**

### 26.3.4 super

화살표 함수는 `super` 바인딩을 갖지 않고, 상위 스코프의 `super`를 참조한다.

### 26.3.5 arguments

화살표 함수는 자체적인 `arguments` 바인딩을 갖지 않고, 상위 스코프의 `arguments`를 참조한다. 따라서 화살표 함수에서 가변 인수를 다루려면 **Rest 파라미터**를 사용해야 한다.

## 26.4 Rest 파라미터

### 26.4.1 기본 문법

Rest 파라미터(`...파라미터명`)는 나머지 인수들을 **배열**로 전달받는다.

```javascript
function foo(...rest) {
  console.log(rest); // [1, 2, 3, 4, 5]
}
foo(1, 2, 3, 4, 5);

// 일반 매개변수와 함께 사용 가능
function bar(first, ...rest) {
  console.log(first); // 1
  console.log(rest);  // [2, 3, 4, 5]
}
bar(1, 2, 3, 4, 5);
```

- Rest 파라미터는 먼저 선언된 매개변수에 할당된 인수를 제외한 나머지 인수들로 구성된 배열이 할당된다.
- 반드시 **마지막 파라미터**여야 한다.
- **단 하나만** 선언할 수 있다.

### 26.4.2 Rest 파라미터와 arguments 객체

`arguments` 객체는 호출 시 전달된 인수들의 정보를 담고 있는 **유사 배열 객체**여서, 배열 메서드를 사용하려면 `Array.from` 등으로 변환이 필요했다.

ES6에서는 Rest 파라미터를 사용하여 이런 번거로움을 피할 수 있다. 또한, 화살표 함수에는 `arguments` 객체가 없으므로 화살표 함수에서는 반드시 Rest 파라미터를 사용해야 한다.

## 26.5 매개변수 기본값

매개변수에 값을 전달하지 않으면 `undefined`가 할당되어 의도치 않은 결과가 발생할 수 있다.

```javascript
function sum(x, y) {
  return x + y;
}
console.log(sum(1)); // NaN (1 + undefined)
```

ES6에서 도입된 **매개변수 기본값**을 사용하면 이를 해결할 수 있다.

```javascript
function sum(x = 0, y = 0) {
  return x + y;
}
console.log(sum(1));    // 1
console.log(sum(1, 2)); // 3
```

- Rest 파라미터에는 기본값을 지정할 수 없다.
- 매개변수 기본값은 함수의 `length` 프로퍼티와 `arguments` 객체에 영향을 주지 않는다.
