# 26장 ES6 함수의 추가 기능

## 메서드

메서드 축약 표현으로 정의된 함수만을 메서드라고 한다. 이는 단순한 용어의 변경이 아니라, 함수의 동작 방식에 실질적인 차이를 가져왔다.

```javascript
const obj = {
  x: 1,
  foo() {
    return this.x;
  }, // 메서드
};
```

이렇게 정의된 메서드는 non-constructor다. 즉, new 연산자와 함께 호출할 수 없다. 이는 메서드가 객체의 동작을 정의하는 용도로만 사용되어야 한다는 개념을 강화한 것이다.

또한, ES6 메서드는 prototype 프로퍼티를 가지지 않으며, 프로토타입 객체도 생성하지 않는다. 이는 메모리 사용을 최적화하고, 메서드의 본질적인 용도에 집중할 수 있게 한다.

ES6 메서드의 또 다른 중요한 특징은 내부 슬롯 [[HomeObject]]를 갖는다는 것이다. 이 슬롯은 메서드가 바인딩된 객체를 가리키며, super 키워드의 동작을 가능하게 한다. super 키워드를 통해 메서드는 자신이 바인딩된 객체의 프로토타입에 쉽게 접근할 수 있다.

```javascript
const base = {
  name: "Lee",
  sayHi() {
    return `Hi! ${this.name}`;
  },
};

const derived = {
  __proto__: base,
  sayHi() {
    return `${super.sayHi()}. How are you doing?`;
  },
};

console.log(derived.sayHi()); // "Hi! Lee. How are you doing?"
```

## 화살표 함수

ES6에서 도입된 새로운 함수 정의 방식이다. function 키워드 대신 화살표(=>)를 사용하여 더욱 간략한 방법으로 함수를 정의할 수 있다. 하지만 화살표 함수는 단순히 기존 함수를 축약한 표현이 아니다. 화살표 함수는 내부 동작도 기존의 함수보다 간략화되어 있으며, 콜백 함수 내부에서 this가 전역 객체를 가리키는 문제를 해결하는 대안으로 유용하게 사용된다.

### 화살표 함수 정의

화살표 함수는 함수 선언문으로 정의할 수 없고 함수 표현식으로만 정의해야 한다. 기본적인 화살표 함수의 정의 방식은 다음과 같다.

```javascript
const multiply = (x, y) => x \* y;
console.log(multiply(2, 3)); // 6
```

화살표 함수의 매개변수가 여러 개인 경우 소괄호 () 안에 매개변수를 선언한다. 매개변수가 하나뿐이라면 소괄호를 생략할 수 있다. 매개변수가 없는 경우 소괄호를 생략할 수 없다.

```javascript
const arrow1 = (x, y) => { ... }; // 매개변수가 여러 개인 경우
const arrow2 = x => { ... }; // 매개변수가 하나인 경우
const arrow3 = () => { ... }; // 매개변수가 없는 경우
```

함수 몸체 정의에 있어서, 함수 몸체가 하나의 문으로 구성된다면 함수 몸체를 감싸는 중괄호 {}를 생략할 수 있다. 이때 함수 몸체 내부의 문이 값으로 평가될 수 있는 표현식인 문이라면 암묵적으로 반환된다.

```javascript
const power = x => x \*\* 2;
console.log(power(2)); // 4
```

객체 리터럴을 반환하는 경우에는 객체 리터럴을 소괄호 ()로 감싸주어야 한다. 그렇지 않으면 객체 리터럴의 중괄호 {}를 함수 몸체를 감싸는 중괄호로 잘못 해석한다.

```javascript
const createObj = (id, content) => ({ id, content });
console.log(createObj(1, "JavaScript")); // {id: 1, content: "JavaScript"}
```

화살표 함수도 즉시 실행 함수(IIFE)로 사용할 수 있으며, 일급 객체이므로 고차 함수(Array.prototype.map, filter, reduce 등)에 인수로 전달할 수 있다. 이는 기존의 함수 표현식보다 표현이 간결하고 가독성이 좋다.

### 화살표 함수와 일반 함수의 차이

#### 일반 함수: "나를 부른 사람이 주인이다" (Dynamic Binding)

일반 함수(function 키워드 사용)에서 this는 함수를 호출한 객체를 가리킵니다. 호출하는 순간에 주인이 결정되기 때문에 '다이내믹(동적) 바인딩'이라고 부른다.

똑같은 함수라도 누가 호출하느냐에 따라 this가 계속 변합니다. 만약 아무도 호출하지 않고 그냥 함수만 실행하면 전역 객체(브라우저에서는 window)가 주인이 된다.

#### 화살표 함수: "나는 태어난 곳의 주인을 따른다" (Lexical this)

화살표 함수(=>)는 자신만의 this를 아예 가지지 않습니다. 대신 함수가 선언된 위치에서 상위 스코프의 this를 그대로 물려받습니다. 이를 '렉시컬(정적) 바인딩'이라고 한다.

한 번 결정된 this는 절대 변하지 않습니다. call, apply, bind 같은 함수로 강제로 바꾸려 해도 무시한다.

#### setTimeout

일반 함수

```javaScript
const user = {
  name: '별코딩',
  sayHi: function() {
    setTimeout(function() {
      console.log(this.name); // 결과: undefined (또는 빈 값)
    }, 1000);
  }
};
```

위 코드에서 setTimeout 안의 일반 함수는 user가 호출한 게 아니라 브라우저가 호출한다. 그래서 this가 window를 가리키게 되고, window.name은 없으므로 오류가 나거나 빈 값이 나온다.

화살표 함수

```javaScript
const user = {
  name: '별코딩',
  sayHi: function() {
    setTimeout(() => {
      console.log(this.name); // 결과: '별코딩'
    }, 1000);
  }
};
```

화살표 함수를 쓰면, 이 함수는 sayHi라는 일반 함수 내부에서 생성되었다. 따라서 sayHi의 this(즉, user 객체)를 그대로 물려받아 별도의 처리 없이도 의도한 대로 동작한다.

#### bind

일반 함수
this가 동적으로 변하기 때문에, 개발자가 bind()를 통해 주인을 강제로 지정할 수 있다. 한 번 바인딩되면 그 함수는 호출 방식과 상관없이 무조건 지정된 객체만 바라본다.

```javascript
function greet() {
  console.log(`안녕하세요, ${this.name}님!`);
}

const user1 = { name: "민수" };
const user2 = { name: "영희" };

// greet 함수의 this를 user1로 고정시킨 새로운 함수를 만듦
const greetMinsu = greet.bind(user1);

greetMinsu(); // 결과: 안녕하세요, 민수님!
greetMinsu.call(user2); // 강제로 user2를 넣어도 무시하고 '민수' 출력
```

화살표 함수
bind(user)를 실행해도 에러는 나지 않지만, 결과는 아무런 변화가 없다. 화살표 함수는 자신이 선언된 환경의 this를 끝까지 고수한다.

```javascript
const name = "전역 객체";
const user = { name: "별코딩" };

const arrowFunc = () => {
  console.log(this.name);
};

// 화살표 함수에 bind를 시도해봄
const boundArrow = arrowFunc.bind(user);

boundArrow(); // 결과: '전역 객체' (또는 undefined)
```
