# 34장 이터러블

## 34.1 이터레이션 프로토콜

ES6에서 도입된 이터레이션 프로토콜은 순회 가능한 자료구조를 만들기 위해 ECMAScript 사양에서 정의한 규칙이다. ES6 이전에는 배열, 문자열 등 순회 가능한 자료구조들이 각자의 방법으로 순회되었지만, ES6 이후에는 이터레이션 프로토콜을 따르는 이터러블로 통일하여 일원화했다.

이터레이션 프로토콜은 두 가지 규칙으로 구성된다.

**1. 이터러블 프로토콜**

`Symbol.iterator`를 키로 갖는 메서드를 구현하거나 상속받은 객체. 이 메서드를 호출하면 이터레이터를 반환해야 한다. 이터러블은 `for...of` 문으로 순회할 수 있고, 스프레드 문법과 구조 분해 할당을 사용할 수 있다.

**2. 이터레이터 프로토콜**

`Symbol.iterator` 메서드를 호출했을 때 반환되는 객체가 지켜야 하는 규칙. 반환된 이터레이터는 반드시 `next` 메서드를 가져야 한다.

**3. 이터레이터 리절트 객체**

`next` 메서드를 호출할 때마다 반환하는 `{ value, done }` 형태의 객체.

- `value`: 현재 순회 중인 값
- `done`: 순회 완료 여부 (완료면 `true`, 미완료면 `false`)

### 34.1.1 이터러블

`Symbol.iterator` 메서드를 갖는 객체로, `for...of` 문으로 순회할 수 있다.

```javascript
const arr = [1, 2, 3];

// 배열은 Array.prototype의 Symbol.iterator 메서드를 상속받는 이터러블
console.log(Symbol.iterator in arr); // true

// for...of 문으로 순회 가능
for (const i of arr) {
  console.log(i); // 1, 2, 3
}

// 스프레드 문법 사용 가능
console.log([...arr]); // [1, 2, 3]

// 구조 분해 할당 사용 가능
const [a, ...rest] = arr;
console.log(a, rest); // 1, [2, 3]

// 일반 객체는 Symbol.iterator 메서드를 갖지 않으므로 for...of 순회 불가
const obj = { a: 1, b: 2 };

// 단, 스프레드 문법은 허용된다 (TC39 Stage 4 제안으로 추가됨)
console.log({ ...obj }); // { a: 1, b: 2 }
```

### 34.1.2 이터레이터

`Symbol.iterator` 메서드를 호출하면 이터레이터 프로토콜을 준수한 이터레이터를 반환한다. 이터레이터는 `next` 메서드를 가지며, `next`를 호출할 때마다 이터레이터 리절트 객체를 반환한다.

```javascript
const arr = [1, 2, 3];
const iterator = arr[Symbol.iterator]();

console.log("next" in iterator); // true

// next를 호출하면 { value, done }을 가지는 이터레이터 리절트 객체를 반환
console.log(iterator.next()); // { value: 1, done: false }
console.log(iterator.next()); // { value: 2, done: false }
console.log(iterator.next()); // { value: 3, done: false }
console.log(iterator.next()); // { value: undefined, done: true }
```

## 34.2 빌트인 이터러블

자바스크립트는 이터레이션 프로토콜을 준수하는 빌트인 이터러블을 제공한다.

| 빌트인 이터러블 | `Symbol.iterator` 메서드 |
|--------------|------------------------|
| Array        | `Array.prototype[Symbol.iterator]` |
| String       | `String.prototype[Symbol.iterator]` |
| Map          | `Map.prototype[Symbol.iterator]` |
| Set          | `Set.prototype[Symbol.iterator]` |
| TypedArray   | `TypedArray.prototype[Symbol.iterator]` |
| arguments    | `arguments[Symbol.iterator]` |
| DOM 컬렉션    | `NodeList.prototype[Symbol.iterator]`, `HTMLCollection.prototype[Symbol.iterator]` |

## 34.3 for...of 문

| 구분       | 일반 `for` 문       | `for...in` 문                  | `for...of` 문                  |
|----------|:-----------------:|:-----------------------------:|:-----------------------------:|
| 핵심 키워드 | 인덱스(Index)       | 프로퍼티 키(Key)                | 값(Value)                      |
| 추적 대상  | 숫자를 올리며 직접 접근 | 열거 가능한 키를 순회             | 이터러블 프로토콜을 따름          |
| 주요 대상  | 배열, 유사 배열      | 일반 객체                       | 배열, 문자열, 이터러블           |
| 특징      | 가장 빠르고 세밀함    | 상속받은 프로토타입 속성까지 순회  | 가장 깔끔하고 최신 방식           |

**`for...in`**

- 기준: 프로퍼티 어트리뷰트 `[[Enumerable]]`이 `true`인 프로퍼티를 순회한다.
- 범위: 자신의 프로퍼티뿐만 아니라 상속받은 프로토타입의 키까지 순회한다.

**`for...of`**

- 기준: 이터러블 프로토콜(`Symbol.iterator` 존재 여부)을 따른다. 이터레이터 리절트 객체의 `done`이 `true`가 되면 순회를 멈춘다.
- 범위: 이터레이터가 반환하는 값만 순서대로 가져온다. 상속받은 프로퍼티 키는 무시한다.

## 34.4 이터러블과 유사 배열 객체

유사 배열 객체는 `length` 프로퍼티를 갖기 때문에 일반 `for` 문으로 순회할 수 있고, 인덱스로 프로퍼티 값에 접근할 수 있다. 하지만 `Symbol.iterator` 메서드가 없으므로 이터러블이 아니어서 `for...of` 문으로 순회할 수 없다.

단, `arguments`, `NodeList`, `HTMLCollection`은 유사 배열 객체이면서 동시에 이터러블이다.

## 34.5 이터레이션 프로토콜의 필요성

이터레이션 프로토콜은 다양한 데이터 공급자(배열, 문자열, Map, Set 등)가 하나의 순회 방식(`for...of`)을 갖도록 규정하여 데이터 소비자(for...of, 스프레드 문법, 구조 분해 할당 등)가 효율적으로 데이터를 사용할 수 있도록 하는 인터페이스 역할을 한다.

## 34.6 사용자 정의 이터러블

### 34.6.1 사용자 정의 이터러블 구현

이터레이션 프로토콜을 준수하도록 `Symbol.iterator` 메서드를 구현하면 사용자 정의 이터러블을 만들 수 있다.

```javascript
const fibonacci = {
  // 이터러블 프로토콜: Symbol.iterator 메서드 구현
  [Symbol.iterator]() {
    let [pre, cur] = [0, 1];
    const max = 10;

    // 이터레이터 프로토콜: next 메서드를 갖는 객체 반환
    return {
      next() {
        [pre, cur] = [cur, pre + cur];
        // 이터레이터 리절트 객체 반환: { value, done }
        return { value: cur, done: cur >= max };
      },
    };
  },
};

for (const num of fibonacci) {
  console.log(num); // 1, 2, 3, 5, 8
}
```

### 34.6.2 이터러블을 생성하는 함수

최대값을 인수로 받아 이터러블을 반환하는 함수로 만들면 재사용성이 높아진다.

```javascript
const fibonacciFunc = function (max) {
  let [pre, cur] = [0, 1];

  return {
    [Symbol.iterator]() {
      return {
        next() {
          [pre, cur] = [cur, pre + cur];
          return { value: cur, done: cur >= max };
        },
      };
    },
  };
};

for (const num of fibonacciFunc(10)) {
  console.log(num); // 1, 2, 3, 5, 8
}
```

### 34.6.3 이터러블이면서 이터레이터인 객체를 생성하는 함수

`Symbol.iterator`가 자기 자신(`this`)을 반환하도록 구현하면 이터러블이면서 동시에 이터레이터인 객체를 만들 수 있다.

```javascript
const fibonacciFunc = function (max) {
  let [pre, cur] = [0, 1];

  return {
    // 이터러블: Symbol.iterator가 자신(this)을 반환
    [Symbol.iterator]() {
      return this;
    },
    // 이터레이터: next 메서드 보유
    next() {
      [pre, cur] = [cur, pre + cur];
      return { value: cur, done: cur >= max };
    },
  };
};

// iter는 이터러블이면서 이터레이터다
let iter = fibonacciFunc(10);

for (const num of iter) {
  console.log(num); // 1, 2, 3, 5, 8
}
```

### 34.6.4 무한 이터러블과 지연 평가

`done` 프로퍼티를 생략하면 무한히 값을 생성하는 무한 이터러블을 만들 수 있다. 이때 **지연 평가(lazy evaluation)** 기법이 사용된다.

> **지연 평가**: 데이터가 필요한 시점 이전까지는 미리 데이터를 생성하지 않다가, 필요한 시점이 되었을 때 비로소 데이터를 생성하는 기법.

```javascript
const fibonacciFunc = function () {
  let [pre, cur] = [0, 1];

  return {
    [Symbol.iterator]() { return this; },
    next() {
      [pre, cur] = [cur, pre + cur];
      // done을 생략하면 무한 이터러블이 된다
      return { value: cur };
    },
  };
};

// 필요한 시점에만 값을 생성하므로 메모리 낭비가 없다
for (const num of fibonacciFunc()) {
  if (num > 10000) break;
  console.log(num);
}

// 구조 분해 할당으로 필요한 데이터만 취득
const [f1, f2, f3] = fibonacciFunc();
console.log(f1, f2, f3); // 1, 2, 3
```
